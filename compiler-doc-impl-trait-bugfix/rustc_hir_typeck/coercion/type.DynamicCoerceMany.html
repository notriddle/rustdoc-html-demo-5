<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The type of a `CoerceMany` that is storing up the expressions into a buffer. We use this in `check/mod.rs` for things like `break`."><title>DynamicCoerceMany in rustc_hir_typeck::coercion - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="rustc_hir_typeck" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0-dev" data-channel="nightly" data-search-js="search-5f5ec5419eadd0c9.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../rustc_hir_typeck/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../../rustc_hir_typeck/index.html"><img class="rust-logo" src="../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">DynamicCoerceMany</a></h2><div class="sidebar-elems"><section><h3><a href="#aliased-type">Aliased type</a></h3><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield.expected_ty">expected_ty</a></li><li><a href="#structfield.expressions">expressions</a></li><li><a href="#structfield.final_ty">final_ty</a></li><li><a href="#structfield.pushed">pushed</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.coerce">coerce</a></li><li><a href="#method.coerce_forced_unit">coerce_forced_unit</a></li><li><a href="#method.coerce_inner">coerce_inner</a></li><li><a href="#method.complete">complete</a></li><li><a href="#method.expected_ty">expected_ty</a></li><li><a href="#method.is_return_ty_definitely_unsized">is_return_ty_definitely_unsized</a></li><li><a href="#method.make">make</a></li><li><a href="#method.merged_ty">merged_ty</a></li><li><a href="#method.new">new</a></li><li><a href="#method.note_unreachable_loop_return">note_unreachable_loop_return</a></li><li><a href="#method.report_return_mismatched_types">report_return_mismatched_types</a></li><li><a href="#method.with_coercion_sites">with_coercion_sites</a></li></ul></section><h2><a href="index.html">In rustc_hir_typeck::coercion</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Type Alias <a href="../index.html">rustc_hir_typeck</a>::<wbr><a href="index.html">coercion</a>::<wbr><a class="type" href="#">DynamicCoerceMany</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/rustc_hir_typeck/coercion.rs.html#1370">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub type DynamicCoerceMany&lt;'tcx&gt; = <a class="struct" href="struct.CoerceMany.html" title="struct rustc_hir_typeck::coercion::CoerceMany">CoerceMany</a>&lt;'tcx, 'tcx, &amp;'tcx <a class="struct" href="../../rustc_hir/hir/struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a>&lt;'tcx&gt;&gt;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The type of a <code>CoerceMany</code> that is storing up the expressions into
a buffer. We use this in <code>check/mod.rs</code> for things like <code>break</code>.</p>
</div></details><h2 id="aliased-type" class="small-section-header">Aliased Type<a href="#aliased-type" class="anchor">§</a></h2><pre class="rust item-decl"><code>struct DynamicCoerceMany&lt;'tcx&gt; {
    expected_ty: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;,
    final_ty: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;&gt;,
    expressions: <a class="enum" href="enum.Expressions.html" title="enum rustc_hir_typeck::coercion::Expressions">Expressions</a>&lt;'tcx, 'tcx, &amp;'tcx <a class="struct" href="../../rustc_hir/hir/struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a>&lt;'tcx&gt;&gt;,
    pushed: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
}</code></pre><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.expected_ty" class="structfield small-section-header"><a href="#structfield.expected_ty" class="anchor field">§</a><code>expected_ty: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;</code></span><span id="structfield.final_ty" class="structfield small-section-header"><a href="#structfield.final_ty" class="anchor field">§</a><code>final_ty: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;&gt;</code></span><span id="structfield.expressions" class="structfield small-section-header"><a href="#structfield.expressions" class="anchor field">§</a><code>expressions: <a class="enum" href="enum.Expressions.html" title="enum rustc_hir_typeck::coercion::Expressions">Expressions</a>&lt;'tcx, 'tcx, &amp;'tcx <a class="struct" href="../../rustc_hir/hir/struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a>&lt;'tcx&gt;&gt;</code></span><span id="structfield.pushed" class="structfield small-section-header"><a href="#structfield.pushed" class="anchor field">§</a><code>pushed: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code></span><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-CoerceMany%3C'tcx,+'exprs,+E%3E" class="impl"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1377-1842">source</a><a href="#impl-CoerceMany%3C'tcx,+'exprs,+E%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'tcx, 'exprs, E: <a class="trait" href="trait.AsCoercionSite.html" title="trait rustc_hir_typeck::coercion::AsCoercionSite">AsCoercionSite</a>&gt; <a class="struct" href="struct.CoerceMany.html" title="struct rustc_hir_typeck::coercion::CoerceMany">CoerceMany</a>&lt;'tcx, 'exprs, E&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1381-1383">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(expected_ty: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>The usual case; collect the set of expressions dynamically.
If the full set of coercion sites is known before hand,
consider <code>with_coercion_sites()</code> instead to avoid allocation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_coercion_sites" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1390-1392">source</a><h4 class="code-header">pub fn <a href="#method.with_coercion_sites" class="fn">with_coercion_sites</a>(
    expected_ty: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;,
    coercion_sites: &amp;'exprs <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[E]</a>
) -&gt; Self</h4></section></summary><div class="docblock"><p>As an optimization, you can create a <code>CoerceMany</code> with a
preexisting slice of expressions. In this case, you are
expected to pass each element in the slice to <code>coerce(...)</code> in
order. This is used with arrays in particular to avoid
needlessly cloning the slice.</p>
</div></details><section id="method.make" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1394-1396">source</a><h4 class="code-header">fn <a href="#method.make" class="fn">make</a>(
    expected_ty: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;,
    expressions: <a class="enum" href="enum.Expressions.html" title="enum rustc_hir_typeck::coercion::Expressions">Expressions</a>&lt;'tcx, 'exprs, E&gt;
) -&gt; Self</h4></section><details class="toggle method-toggle" open><summary><section id="method.expected_ty" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1406-1408">source</a><h4 class="code-header">pub fn <a href="#method.expected_ty" class="fn">expected_ty</a>(&amp;self) -&gt; <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;</h4></section></summary><div class="docblock"><p>Returns the “expected type” with which this coercion was
constructed. This represents the “downward propagated” type
that was given to us at the start of typing whatever construct
we are typing (e.g., the match expression).</p>
<p>Typically, this is used as the expected type when
type-checking each of the alternative expressions whose types
we are trying to merge.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.merged_ty" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1414-1416">source</a><h4 class="code-header">pub fn <a href="#method.merged_ty" class="fn">merged_ty</a>(&amp;self) -&gt; <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;</h4></section></summary><div class="docblock"><p>Returns the current “merged type”, representing our best-guess
at the LUB of the expressions we’ve seen so far (if any). This
isn’t <em>final</em> until you call <code>self.complete()</code>, which will return
the merged type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.coerce" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1423-1431">source</a><h4 class="code-header">pub fn <a href="#method.coerce" class="fn">coerce</a>&lt;'a&gt;(
    &amp;mut self,
    fcx: &amp;<a class="struct" href="../fn_ctxt/struct.FnCtxt.html" title="struct rustc_hir_typeck::fn_ctxt::FnCtxt">FnCtxt</a>&lt;'a, 'tcx&gt;,
    cause: &amp;<a class="struct" href="../../rustc_middle/traits/struct.ObligationCause.html" title="struct rustc_middle::traits::ObligationCause">ObligationCause</a>&lt;'tcx&gt;,
    expression: &amp;'tcx <a class="struct" href="../../rustc_hir/hir/struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a>&lt;'tcx&gt;,
    expression_ty: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;
)</h4></section></summary><div class="docblock"><p>Indicates that the value generated by <code>expression</code>, which is
of type <code>expression_ty</code>, is one of the possibilities that we
could coerce from. This will record <code>expression</code>, and later
calls to <code>coerce</code> may come back and add adjustments and things
if necessary.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.coerce_forced_unit" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1445-1460">source</a><h4 class="code-header">pub fn <a href="#method.coerce_forced_unit" class="fn">coerce_forced_unit</a>&lt;'a&gt;(
    &amp;mut self,
    fcx: &amp;<a class="struct" href="../fn_ctxt/struct.FnCtxt.html" title="struct rustc_hir_typeck::fn_ctxt::FnCtxt">FnCtxt</a>&lt;'a, 'tcx&gt;,
    cause: &amp;<a class="struct" href="../../rustc_middle/traits/struct.ObligationCause.html" title="struct rustc_middle::traits::ObligationCause">ObligationCause</a>&lt;'tcx&gt;,
    augment_error: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut <a class="struct" href="../../rustc_errors/diagnostic/struct.Diagnostic.html" title="struct rustc_errors::diagnostic::Diagnostic">Diagnostic</a>),
    label_unit_as_expected: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>
)</h4></section></summary><div class="docblock"><p>Indicates that one of the inputs is a “forced unit”. This
occurs in a case like <code>if foo { ... };</code>, where the missing else
generates a “forced unit”. Another example is a <code>loop { break; }</code>, where the <code>break</code> has no argument expression. We treat
these cases slightly differently for error-reporting
purposes. Note that these tend to correspond to cases where
the <code>()</code> expression is implicit in the source, and hence we do
not take an expression argument.</p>
<p>The <code>augment_error</code> gives you a chance to extend the error
message, in case any results (e.g., we use this to suggest
removing a <code>;</code>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.coerce_inner" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1465">source</a><h4 class="code-header">pub(crate) fn <a href="#method.coerce_inner" class="fn">coerce_inner</a>&lt;'a&gt;(
    &amp;mut self,
    fcx: &amp;<a class="struct" href="../fn_ctxt/struct.FnCtxt.html" title="struct rustc_hir_typeck::fn_ctxt::FnCtxt">FnCtxt</a>&lt;'a, 'tcx&gt;,
    cause: &amp;<a class="struct" href="../../rustc_middle/traits/struct.ObligationCause.html" title="struct rustc_middle::traits::ObligationCause">ObligationCause</a>&lt;'tcx&gt;,
    expression: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'tcx <a class="struct" href="../../rustc_hir/hir/struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a>&lt;'tcx&gt;&gt;,
    expression_ty: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;,
    augment_error: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;mut <a class="struct" href="../../rustc_errors/diagnostic/struct.Diagnostic.html" title="struct rustc_errors::diagnostic::Diagnostic">Diagnostic</a>),
    label_expression_as_expected: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>
)</h4></section></summary><div class="docblock"><p>The inner coercion “engine”. If <code>expression</code> is <code>None</code>, this
is a forced-unit case, and hence <code>expression_ty</code> must be
<code>Nil</code>.</p>
</div></details><section id="method.note_unreachable_loop_return" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1675-1708">source</a><h4 class="code-header">fn <a href="#method.note_unreachable_loop_return" class="fn">note_unreachable_loop_return</a>(
    &amp;self,
    err: &amp;mut <a class="struct" href="../../rustc_errors/diagnostic/struct.Diagnostic.html" title="struct rustc_errors::diagnostic::Diagnostic">Diagnostic</a>,
    expr: &amp;<a class="struct" href="../../rustc_hir/hir/struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a>&lt;'tcx&gt;,
    ret_exprs: &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;&amp;'tcx <a class="struct" href="../../rustc_hir/hir/struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a>&lt;'tcx&gt;&gt;
)</h4></section><section id="method.report_return_mismatched_types" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1710-1810">source</a><h4 class="code-header">fn <a href="#method.report_return_mismatched_types" class="fn">report_return_mismatched_types</a>&lt;'a&gt;(
    &amp;self,
    cause: &amp;<a class="struct" href="../../rustc_middle/traits/struct.ObligationCause.html" title="struct rustc_middle::traits::ObligationCause">ObligationCause</a>&lt;'tcx&gt;,
    expected: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;,
    found: <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;,
    ty_err: <a class="enum" href="../../rustc_middle/ty/error/enum.TypeError.html" title="enum rustc_middle::ty::error::TypeError">TypeError</a>&lt;'tcx&gt;,
    fcx: &amp;<a class="struct" href="../fn_ctxt/struct.FnCtxt.html" title="struct rustc_hir_typeck::fn_ctxt::FnCtxt">FnCtxt</a>&lt;'a, 'tcx&gt;,
    id: <a class="struct" href="../../rustc_hir/hir_id/struct.HirId.html" title="struct rustc_hir::hir_id::HirId">HirId</a>,
    expression: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'tcx <a class="struct" href="../../rustc_hir/hir/struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a>&lt;'tcx&gt;&gt;,
    blk_id: <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../rustc_hir/hir_id/struct.HirId.html" title="struct rustc_hir::hir_id::HirId">HirId</a>&gt;
) -&gt; <a class="struct" href="../../rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html" title="struct rustc_errors::diagnostic_builder::DiagnosticBuilder">DiagnosticBuilder</a>&lt;'a, <a class="struct" href="../../rustc_span/struct.ErrorGuaranteed.html" title="struct rustc_span::ErrorGuaranteed">ErrorGuaranteed</a>&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.is_return_ty_definitely_unsized" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1815-1830">source</a><h4 class="code-header">fn <a href="#method.is_return_ty_definitely_unsized" class="fn">is_return_ty_definitely_unsized</a>(&amp;self, fcx: &amp;<a class="struct" href="../fn_ctxt/struct.FnCtxt.html" title="struct rustc_hir_typeck::fn_ctxt::FnCtxt">FnCtxt</a>&lt;'_, 'tcx&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks whether the return type is unsized via an obligation, which makes
sure we consider <code>dyn Trait: Sized</code> where clauses, which are trivially
false but technically valid for typeck.</p>
</div></details><section id="method.complete" class="method"><a class="src rightside" href="../../src/rustc_hir_typeck/coercion.rs.html#1832-1841">source</a><h4 class="code-header">pub fn <a href="#method.complete" class="fn">complete</a>&lt;'a&gt;(self, fcx: &amp;<a class="struct" href="../fn_ctxt/struct.FnCtxt.html" title="struct rustc_hir_typeck::fn_ctxt::FnCtxt">FnCtxt</a>&lt;'a, 'tcx&gt;) -&gt; <a class="struct" href="../../rustc_middle/ty/struct.Ty.html" title="struct rustc_middle::ty::Ty">Ty</a>&lt;'tcx&gt;</h4></section></div></details></div><h2 id="layout" class="small-section-header">Layout<a href="#layout" class="anchor">§</a></h2><div class="docblock"><div class="warning"><p><strong>Note:</strong> Most layout information is <strong>completely unstable</strong> and may even differ between compilations. The only exception is types with certain <code>repr(...)</code> attributes. Please see the Rust Reference's <a href="https://doc.rust-lang.org/reference/type-layout.html">“Type Layout”</a> chapter for details on type layout guarantees.</p></div><p><strong>Size:</strong> 48 bytes</p></div></section></div></main></body></html>