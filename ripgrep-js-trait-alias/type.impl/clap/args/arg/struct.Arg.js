(function() {var type_impls = {
"rg":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Arg%3C'a,+'b%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#65\">source</a><a href=\"#impl-Arg%3C'a,+'b%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.with_name\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#83\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.with_name\" class=\"fn\">with_name</a>(n: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new instance of <a href=\"./struct.Arg.html\"><code>Arg</code></a> using a unique string name. The name will be used to get\ninformation about whether or not the argument was used at runtime, get values, set\nrelationships with other args, etc..</p>\n<p><strong>NOTE:</strong> In the case of arguments that take values (i.e. <a href=\"./struct.Arg.html#method.takes_value\"><code>Arg::takes_value(true)</code></a>)\nand positional arguments (i.e. those without a preceding <code>-</code> or <code>--</code>) the name will also\nbe displayed when the user prints the usage/help information of the program.</p>\n<h5 id=\"examples\"><a href=\"#examples\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.from_usage\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#301\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.from_usage\" class=\"fn\">from_usage</a>(u: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new instance of <a href=\"./struct.Arg.html\"><code>Arg</code></a> from a usage string. Allows creation of basic settings\nfor the <a href=\"./struct.Arg.html\"><code>Arg</code></a>. The syntax is flexible, but there are some rules to follow.</p>\n<p><strong>NOTE</strong>: Not all settings may be set using the usage string method. Some properties are\nonly available via the builder pattern.</p>\n<p><strong>NOTE</strong>: Only ASCII values are officially supported in <a href=\"./struct.Arg.html#method.from_usage\"><code>Arg::from_usage</code></a> strings. Some\nUTF-8 codepoints may work just fine, but this is not guaranteed.</p>\n<h5 id=\"syntax\"><a href=\"#syntax\">Syntax</a></h5>\n<p>Usage strings typically following the form:</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>[explicit name] [short] [long] [value names] [help string]\n</code></pre></div>\n<p>This is not a hard rule as the attributes can appear in other orders. There are also\nseveral additional sigils which denote additional settings. Below are the details of each\nportion of the string.</p>\n<h6 id=\"explicit-name\"><a href=\"#explicit-name\">Explicit Name</a></h6>\n<p>This is an optional field, if it’s omitted the argument will use one of the additional\nfields as the name using the following priority order:</p>\n<ul>\n<li>Explicit Name (This always takes precedence when present)</li>\n<li>Long</li>\n<li>Short</li>\n<li>Value Name</li>\n</ul>\n<p><code>clap</code> determines explicit names as the first string of characters between either <code>[]</code> or\n<code>&lt;&gt;</code> where <code>[]</code> has the dual notation of meaning the argument is optional, and <code>&lt;&gt;</code> meaning\nthe argument is required.</p>\n<p>Explicit names may be followed by:</p>\n<ul>\n<li>The multiple denotation <code>...</code></li>\n</ul>\n<p>Example explicit names as follows (<code>ename</code> for an optional argument, and <code>rname</code> for a\nrequired argument):</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>[ename] -s, --long &#39;some flag&#39;\n&lt;rname&gt; -r, --longer &#39;some other flag&#39;\n</code></pre></div><h6 id=\"short\"><a href=\"#short\">Short</a></h6>\n<p>This is set by placing a single character after a leading <code>-</code>.</p>\n<p>Shorts may be followed by</p>\n<ul>\n<li>The multiple denotation <code>...</code></li>\n<li>An optional comma <code>,</code> which is cosmetic only</li>\n<li>Value notation</li>\n</ul>\n<p>Example shorts are as follows (<code>-s</code>, and <code>-r</code>):</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>-s, --long &#39;some flag&#39;\n&lt;rname&gt; -r [val], --longer &#39;some option&#39;\n</code></pre></div><h6 id=\"long\"><a href=\"#long\">Long</a></h6>\n<p>This is set by placing a word (no spaces) after a leading <code>--</code>.</p>\n<p>Shorts may be followed by</p>\n<ul>\n<li>The multiple denotation <code>...</code></li>\n<li>Value notation</li>\n</ul>\n<p>Example longs are as follows (<code>--some</code>, and <code>--rapid</code>):</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>-s, --some &#39;some flag&#39;\n--rapid=[FILE] &#39;some option&#39;\n</code></pre></div><h6 id=\"values-value-notation\"><a href=\"#values-value-notation\">Values (Value Notation)</a></h6>\n<p>This is set by placing a word(s) between <code>[]</code> or <code>&lt;&gt;</code> optionally after <code>=</code> (although this\nis cosmetic only and does not affect functionality). If an explicit name has <strong>not</strong> been\nset, using <code>&lt;&gt;</code> will denote a required argument, and <code>[]</code> will denote an optional argument</p>\n<p>Values may be followed by</p>\n<ul>\n<li>The multiple denotation <code>...</code></li>\n<li>More Value notation</li>\n</ul>\n<p>More than one value will also implicitly set the arguments number of values, i.e. having\ntwo values, <code>--option [val1] [val2]</code> specifies that in order for option to be satisified it\nmust receive exactly two values</p>\n<p>Example values are as follows (<code>FILE</code>, and <code>SPEED</code>):</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>-s, --some [FILE] &#39;some option&#39;\n--rapid=&lt;SPEED&gt;... &#39;some required multiple option&#39;\n</code></pre></div><h6 id=\"help-string\"><a href=\"#help-string\">Help String</a></h6>\n<p>The help string is denoted between a pair of single quotes <code>''</code> and may contain any\ncharacters.</p>\n<p>Example help strings are as follows:</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>-s, --some [FILE] &#39;some option&#39;\n--rapid=&lt;SPEED&gt;... &#39;some required multiple option&#39;\n</code></pre></div><h6 id=\"additional-sigils\"><a href=\"#additional-sigils\">Additional Sigils</a></h6>\n<p>Multiple notation <code>...</code> (three consecutive dots/periods) specifies that this argument may\nbe used multiple times. Do not confuse multiple occurrences (<code>...</code>) with multiple values.\n<code>--option val1 val2</code> is a single occurrence with multiple values. <code>--flag --flag</code> is\nmultiple occurrences (and then you can obviously have instances of both as well)</p>\n<h5 id=\"examples-1\"><a href=\"#examples-1\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .args(<span class=\"kw-2\">&amp;</span>[\n        Arg::from_usage(<span class=\"string\">&quot;--config &lt;FILE&gt; &#39;a required file for the configuration and no short&#39;&quot;</span>),\n        Arg::from_usage(<span class=\"string\">&quot;-d, --debug... &#39;turns on debugging information and allows multiples&#39;&quot;</span>),\n        Arg::from_usage(<span class=\"string\">&quot;[input] &#39;an optional input file to use&#39;&quot;</span>)\n])</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.short\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#342\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.short\" class=\"fn\">short</a>&lt;S&gt;(self, s: S) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;<span class=\"where fmt-newline\">where\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html\" title=\"trait core::convert::AsRef\">AsRef</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>&gt;,</span></h4></section></summary><div class=\"docblock\"><p>Sets the short version of the argument without the preceding <code>-</code>.</p>\n<p>By default <code>clap</code> automatically assigns <code>V</code> and <code>h</code> to the auto-generated <code>version</code> and\n<code>help</code> arguments respectively. You may use the uppercase <code>V</code> or lowercase <code>h</code> for your own\narguments, in which case <code>clap</code> simply will not assign those to the auto-generated\n<code>version</code> or <code>help</code> arguments.</p>\n<p><strong>NOTE:</strong> Any leading <code>-</code> characters will be stripped, and only the first\nnon <code>-</code> character will be used as the <a href=\"./struct.Arg.html#method.short\"><code>short</code></a> version</p>\n<h5 id=\"examples-2\"><a href=\"#examples-2\">Examples</a></h5>\n<p>To set <a href=\"./struct.Arg.html#method.short\"><code>short</code></a> use a single valid UTF-8 code point. If you supply a leading <code>-</code> such as\n<code>-c</code>, the <code>-</code> will be stripped.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .short(<span class=\"string\">&quot;c&quot;</span>)</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.short\"><code>short</code></a> allows using the argument via a single hyphen (<code>-</code>) such as <code>-c</code></p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n        .short(<span class=\"string\">&quot;c&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-c&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;config&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.long\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#382\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.long\" class=\"fn\">long</a>(self, l: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets the long version of the argument without the preceding <code>--</code>.</p>\n<p>By default <code>clap</code> automatically assigns <code>version</code> and <code>help</code> to the auto-generated\n<code>version</code> and <code>help</code> arguments respectively. You may use the word <code>version</code> or <code>help</code> for\nthe long form of your own arguments, in which case <code>clap</code> simply will not assign those to\nthe auto-generated <code>version</code> or <code>help</code> arguments.</p>\n<p><strong>NOTE:</strong> Any leading <code>-</code> characters will be stripped</p>\n<h5 id=\"examples-3\"><a href=\"#examples-3\">Examples</a></h5>\n<p>To set <code>long</code> use a word containing valid UTF-8 codepoints. If you supply a double leading\n<code>--</code> such as <code>--config</code> they will be stripped. Hyphens in the middle of the word, however,\nwill <em>not</em> be stripped (i.e. <code>config-file</code> is allowed)</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n    .long(<span class=\"string\">&quot;config&quot;</span>)</code></pre></div>\n<p>Setting <code>long</code> allows using the argument via a double hyphen (<code>--</code>) such as <code>--config</code></p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;cfg&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.alias\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#408\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.alias\" class=\"fn\">alias</a>&lt;S&gt;(self, name: S) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;<span class=\"where fmt-newline\">where\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/convert/trait.Into.html\" title=\"trait core::convert::Into\">Into</a>&lt;&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>&gt;,</span></h4></section></summary><div class=\"docblock\"><p>Allows adding a <a href=\"./struct.Arg.html\"><code>Arg</code></a> alias, which function as “hidden” arguments that\nautomatically dispatch as if this argument was used. This is more efficient, and easier\nthan creating multiple hidden arguments as one only needs to check for the existence of\nthis command, and not all variants.</p>\n<h5 id=\"examples-4\"><a href=\"#examples-4\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n            .arg(Arg::with_name(<span class=\"string\">&quot;test&quot;</span>)\n            .long(<span class=\"string\">&quot;test&quot;</span>)\n            .alias(<span class=\"string\">&quot;alias&quot;</span>)\n            .takes_value(<span class=\"bool-val\">true</span>))\n       .get_matches_from(<span class=\"macro\">vec!</span>[\n            <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--alias&quot;</span>, <span class=\"string\">&quot;cool&quot;\n        </span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;test&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;test&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;cool&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.aliases\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#438\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.aliases\" class=\"fn\">aliases</a>(self, names: &amp;[&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows adding <a href=\"./struct.Arg.html\"><code>Arg</code></a> aliases, which function as “hidden” arguments that\nautomatically dispatch as if this argument was used. This is more efficient, and easier\nthan creating multiple hidden subcommands as one only needs to check for the existence of\nthis command, and not all variants.</p>\n<h5 id=\"examples-5\"><a href=\"#examples-5\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n            .arg(Arg::with_name(<span class=\"string\">&quot;test&quot;</span>)\n                    .long(<span class=\"string\">&quot;test&quot;</span>)\n                    .aliases(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;do-stuff&quot;</span>, <span class=\"string\">&quot;do-tests&quot;</span>, <span class=\"string\">&quot;tests&quot;</span>])\n                    .help(<span class=\"string\">&quot;the file to add&quot;</span>)\n                    .required(<span class=\"bool-val\">false</span>))\n            .get_matches_from(<span class=\"macro\">vec!</span>[\n                <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--do-tests&quot;\n            </span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;test&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.visible_alias\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#469\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.visible_alias\" class=\"fn\">visible_alias</a>&lt;S&gt;(self, name: S) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;<span class=\"where fmt-newline\">where\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/convert/trait.Into.html\" title=\"trait core::convert::Into\">Into</a>&lt;&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>&gt;,</span></h4></section></summary><div class=\"docblock\"><p>Allows adding a <a href=\"./struct.Arg.html\"><code>Arg</code></a> alias that functions exactly like those defined with\n<a href=\"clap/args/arg/struct.Arg.html#method.alias\" title=\"method clap::args::arg::Arg::alias\"><code>Arg::alias</code></a>, except that they are visible inside the help message.</p>\n<h5 id=\"examples-6\"><a href=\"#examples-6\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n            .arg(Arg::with_name(<span class=\"string\">&quot;test&quot;</span>)\n                .visible_alias(<span class=\"string\">&quot;something-awesome&quot;</span>)\n                .long(<span class=\"string\">&quot;test&quot;</span>)\n                .takes_value(<span class=\"bool-val\">true</span>))\n       .get_matches_from(<span class=\"macro\">vec!</span>[\n            <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--something-awesome&quot;</span>, <span class=\"string\">&quot;coffee&quot;\n        </span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;test&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;test&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;coffee&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.visible_aliases\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#496\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.visible_aliases\" class=\"fn\">visible_aliases</a>(self, names: &amp;[&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows adding multiple <a href=\"./struct.Arg.html\"><code>Arg</code></a> aliases that functions exactly like those defined\nwith <a href=\"clap/args/arg/struct.Arg.html#method.aliases\" title=\"method clap::args::arg::Arg::aliases\"><code>Arg::aliases</code></a>, except that they are visible inside the help message.</p>\n<h5 id=\"examples-7\"><a href=\"#examples-7\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n            .arg(Arg::with_name(<span class=\"string\">&quot;test&quot;</span>)\n                .long(<span class=\"string\">&quot;test&quot;</span>)\n                .visible_aliases(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;something&quot;</span>, <span class=\"string\">&quot;awesome&quot;</span>, <span class=\"string\">&quot;cool&quot;</span>]))\n       .get_matches_from(<span class=\"macro\">vec!</span>[\n            <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--awesome&quot;\n        </span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;test&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.help\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#557\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.help\" class=\"fn\">help</a>(self, h: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets the short help text of the argument that will be displayed to the user when they print\nthe help information with <code>-h</code>. Typically, this is a short (one line) description of the\narg.</p>\n<p><strong>NOTE:</strong> If only <code>Arg::help</code> is provided, and not <a href=\"./struct.Arg.html#method.long_help\"><code>Arg::long_help</code></a> but the user requests\n<code>--help</code> clap will still display the contents of <code>help</code> appropriately</p>\n<p><strong>NOTE:</strong> Only <code>Arg::help</code> is used in completion script generation in order to be concise</p>\n<h5 id=\"examples-8\"><a href=\"#examples-8\">Examples</a></h5>\n<p>Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to\ninclude a newline in the help text and have the following text be properly aligned with all\nthe other help text.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .help(<span class=\"string\">&quot;The config file used by the myprog&quot;</span>)</code></pre></div>\n<p>Setting <code>help</code> displays a short message to the side of the argument when the user passes\n<code>-h</code> or <code>--help</code> (by default).</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .help(<span class=\"string\">&quot;Some help text describing the --config arg&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>The above example displays</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>helptest\n\nUSAGE:\n   helptest [FLAGS]\n\nFLAGS:\n    --config     Some help text describing the --config arg\n-h, --help       Prints help information\n-V, --version    Prints version information\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.long_help\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#628\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.long_help\" class=\"fn\">long_help</a>(self, h: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets the long help text of the argument that will be displayed to the user when they print\nthe help information with <code>--help</code>. Typically this a more detailed (multi-line) message\nthat describes the arg.</p>\n<p><strong>NOTE:</strong> If only <code>long_help</code> is provided, and not <a href=\"./struct.Arg.html#method.help\"><code>Arg::help</code></a> but the user requests <code>-h</code>\nclap will still display the contents of <code>long_help</code> appropriately</p>\n<p><strong>NOTE:</strong> Only <a href=\"./struct.Arg.html#method.help\"><code>Arg::help</code></a> is used in completion script generation in order to be concise</p>\n<h5 id=\"examples-9\"><a href=\"#examples-9\">Examples</a></h5>\n<p>Any valid UTF-8 is allowed in the help text. The one exception is when one wishes to\ninclude a newline in the help text and have the following text be properly aligned with all\nthe other help text.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .long_help(\n<span class=\"string\">&quot;The config file used by the myprog must be in JSON format\nwith only valid keys and may not contain other nonsense\nthat cannot be read by this program. Obviously I&#39;m going on\nand on, so I&#39;ll stop now.&quot;</span>)</code></pre></div>\n<p>Setting <code>help</code> displays a short message to the side of the argument when the user passes\n<code>-h</code> or <code>--help</code> (by default).</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .long_help(\n<span class=\"string\">&quot;The config file used by the myprog must be in JSON format\nwith only valid keys and may not contain other nonsense\nthat cannot be read by this program. Obviously I&#39;m going on\nand on, so I&#39;ll stop now.&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>The above example displays</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>helptest\n\nUSAGE:\n   helptest [FLAGS]\n\nFLAGS:\n   --config\n        The config file used by the myprog must be in JSON format\n        with only valid keys and may not contain other nonsense\n        that cannot be read by this program. Obviously I&#39;m going on\n        and on, so I&#39;ll stop now.\n\n-h, --help\n        Prints help information\n\n-V, --version\n        Prints version information\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.last\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#705\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.last\" class=\"fn\">last</a>(self, l: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies that this arg is the last, or final, positional argument (i.e. has the highest\nindex) and is <em>only</em> able to be accessed via the <code>--</code> syntax (i.e. <code>$ prog args -- last_arg</code>). Even, if no other arguments are left to parse, if the user omits the <code>--</code> syntax\nthey will receive an <a href=\"./enum.ErrorKind.html#variant.UnknownArgument\"><code>UnknownArgument</code></a> error. Setting an argument to <code>.last(true)</code> also\nallows one to access this arg early using the <code>--</code> syntax. Accessing an arg early, even with\nthe <code>--</code> syntax is otherwise not possible.</p>\n<p><strong>NOTE:</strong> This will change the usage string to look like <code>$ prog [FLAGS] [-- &lt;ARG&gt;]</code> if\n<code>ARG</code> is marked as <code>.last(true)</code>.</p>\n<p><strong>NOTE:</strong> This setting will imply <a href=\"./enum.AppSettings.html#variant.DontCollapseArgsInUsage\"><code>AppSettings::DontCollapseArgsInUsage</code></a> because failing\nto set this can make the usage string very confusing.</p>\n<p><strong>NOTE</strong>: This setting only applies to positional arguments, and has no affect on FLAGS /\nOPTIONS</p>\n<p><strong>CAUTION:</strong> Setting an argument to <code>.last(true)</code> <em>and</em> having child subcommands is not\nrecommended with the exception of <em>also</em> using <a href=\"./enum.AppSettings.html#variant.ArgsNegateSubcommands\"><code>AppSettings::ArgsNegateSubcommands</code></a>\n(or <a href=\"./enum.AppSettings.html#variant.SubcommandsNegateReqs\"><code>AppSettings::SubcommandsNegateReqs</code></a> if the argument marked <code>.last(true)</code> is also\nmarked <a href=\"./struct.Arg.html#method.required\"><code>.required(true)</code></a>)</p>\n<h5 id=\"examples-10\"><a href=\"#examples-10\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;args&quot;</span>)\n    .last(<span class=\"bool-val\">true</span>)</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.last\"><code>Arg::last(true)</code></a> ensures the arg has the highest <a href=\"./struct.Arg.html#method.index\">index</a> of all positional args\nand requires that the <code>--</code> syntax be used to access it early.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;first&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;second&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;third&quot;</span>).last(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;one&quot;</span>, <span class=\"string\">&quot;--&quot;</span>, <span class=\"string\">&quot;three&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok());\n<span class=\"kw\">let </span>m = res.unwrap();\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;third&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;three&quot;</span>));\n<span class=\"macro\">assert!</span>(m.value_of(<span class=\"string\">&quot;second&quot;</span>).is_none());</code></pre></div>\n<p>Even if the positional argument marked <code>.last(true)</code> is the only argument left to parse,\nfailing to use the <code>--</code> syntax results in an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;first&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;second&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;third&quot;</span>).last(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;one&quot;</span>, <span class=\"string\">&quot;two&quot;</span>, <span class=\"string\">&quot;three&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::UnknownArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.required\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#764\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.required\" class=\"fn\">required</a>(self, r: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets whether or not the argument is required by default. Required by default means it is\nrequired, when no other conflicting rules have been evaluated. Conflicting rules take\nprecedence over being required. <strong>Default:</strong> <code>false</code></p>\n<p><strong>NOTE:</strong> Flags (i.e. not positional, or arguments that take values) cannot be required by\ndefault. This is simply because if a flag should be required, it should simply be implied\nas no additional information is required from user. Flags by their very nature are simply\nyes/no, or true/false.</p>\n<h5 id=\"examples-11\"><a href=\"#examples-11\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .required(<span class=\"bool-val\">true</span>)</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.required\"><code>Arg::required(true)</code></a> requires that the argument be used at runtime.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;file.conf&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok());</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.required\"><code>Arg::required(true)</code></a> and <em>not</em> supplying that argument is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.require_equals\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#826\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.require_equals\" class=\"fn\">require_equals</a>(self, r: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Requires that options use the <code>--option=val</code> syntax (i.e. an equals between the option and\nassociated value) <strong>Default:</strong> <code>false</code></p>\n<p><strong>NOTE:</strong> This setting also removes the default of allowing empty values and implies\n<a href=\"./struct.Arg.html#method.empty_values\"><code>Arg::empty_values(false)</code></a>.</p>\n<h5 id=\"examples-12\"><a href=\"#examples-12\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .long(<span class=\"string\">&quot;config&quot;</span>)\n    .takes_value(<span class=\"bool-val\">true</span>)\n    .require_equals(<span class=\"bool-val\">true</span>)</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.require_equals\"><code>Arg::require_equals(true)</code></a> requires that the option have an equals sign between\nit and the associated value.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .require_equals(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config=file.conf&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok());</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.require_equals\"><code>Arg::require_equals(true)</code></a> and <em>not</em> supplying the equals will cause an error\nunless <a href=\"./struct.Arg.html#method.empty_values\"><code>Arg::empty_values(true)</code></a> is set.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .require_equals(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;file.conf&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::EmptyValue);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.allow_hyphen_values\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#891\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.allow_hyphen_values\" class=\"fn\">allow_hyphen_values</a>(self, a: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows values which start with a leading hyphen (<code>-</code>)</p>\n<p><strong>WARNING</strong>: Take caution when using this setting combined with <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a>, as\nthis becomes ambiguous <code>$ prog --arg -- -- val</code>. All three <code>--, --, val</code> will be values\nwhen the user may have thought the second <code>--</code> would constitute the normal, “Only\npositional args follow” idiom. To fix this, consider using <a href=\"./struct.Arg.html#method.number_of_values\"><code>Arg::number_of_values(1)</code></a></p>\n<p><strong>WARNING</strong>: When building your CLIs, consider the effects of allowing leading hyphens and\nthe user passing in a value that matches a valid short. For example <code>prog -opt -F</code> where\n<code>-F</code> is supposed to be a value, yet <code>-F</code> is <em>also</em> a valid short for another arg. Care should\nshould be taken when designing these args. This is compounded by the ability to “stack”\nshort args. I.e. if <code>-val</code> is supposed to be a value, but <code>-v</code>, <code>-a</code>, and <code>-l</code> are all valid\nshorts.</p>\n<h5 id=\"examples-13\"><a href=\"#examples-13\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;pattern&quot;</span>)\n    .allow_hyphen_values(<span class=\"bool-val\">true</span>)</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;pat&quot;</span>)\n        .allow_hyphen_values(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;pattern&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--pattern&quot;</span>, <span class=\"string\">&quot;-file&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;pat&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;-file&quot;</span>));</code></pre></div>\n<p>Not setting <a href=\"./struct.Arg.html#method.allow_hyphen_values\"><code>Arg::allow_hyphen_values(true)</code></a> and supplying a value which starts with a\nhyphen is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;pat&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;pattern&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--pattern&quot;</span>, <span class=\"string\">&quot;-file&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::UnknownArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.required_unless\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#954\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.required_unless\" class=\"fn\">required_unless</a>(self, name: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets an arg that override this arg’s required setting. (i.e. this arg will be required\nunless this other argument is present).</p>\n<p><strong>Pro Tip:</strong> Using <a href=\"./struct.Arg.html#method.required_unless\"><code>Arg::required_unless</code></a> implies <a href=\"./struct.Arg.html#method.required\"><code>Arg::required</code></a> and is therefore not\nmandatory to also set.</p>\n<h5 id=\"examples-14\"><a href=\"#examples-14\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .required_unless(<span class=\"string\">&quot;debug&quot;</span>)</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.required_unless\"><code>Arg::required_unless(name)</code></a> requires that the argument be used at runtime\n<em>unless</em> <code>name</code> is present. In the following example, the required argument is <em>not</em>\nprovided, but it’s not an error because the <code>unless</code> arg has been supplied.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required_unless(<span class=\"string\">&quot;dbg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;dbg&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--debug&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok());</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.required_unless\"><code>Arg::required_unless(name)</code></a> and <em>not</em> supplying <code>name</code> or this arg is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required_unless(<span class=\"string\">&quot;dbg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;dbg&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.required_unless_all\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1026\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.required_unless_all\" class=\"fn\">required_unless_all</a>(self, names: &amp;[&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets args that override this arg’s required setting. (i.e. this arg will be required unless\nall these other arguments are present).</p>\n<p><strong>NOTE:</strong> If you wish for this argument to only be required if <em>one of</em> these args are\npresent see <a href=\"./struct.Arg.html#method.required_unless_one\"><code>Arg::required_unless_one</code></a></p>\n<h5 id=\"examples-15\"><a href=\"#examples-15\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .required_unless_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;cfg&quot;</span>, <span class=\"string\">&quot;dbg&quot;</span>])</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.required_unless_all\"><code>Arg::required_unless_all(names)</code></a> requires that the argument be used at runtime\n<em>unless</em> <em>all</em> the args in <code>names</code> are present. In the following example, the required\nargument is <em>not</em> provided, but it’s not an error because all the <code>unless</code> args have been\nsupplied.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required_unless_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;dbg&quot;</span>, <span class=\"string\">&quot;infile&quot;</span>])\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;dbg&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;infile&quot;</span>)\n        .short(<span class=\"string\">&quot;i&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--debug&quot;</span>, <span class=\"string\">&quot;-i&quot;</span>, <span class=\"string\">&quot;file&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok());</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.required_unless_all\"><code>Arg::required_unless_all(names)</code></a> and <em>not</em> supplying <em>all</em> of <code>names</code> or this\narg is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required_unless_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;dbg&quot;</span>, <span class=\"string\">&quot;infile&quot;</span>])\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;dbg&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;infile&quot;</span>)\n        .short(<span class=\"string\">&quot;i&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.required_unless_one\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1102\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.required_unless_one\" class=\"fn\">required_unless_one</a>(self, names: &amp;[&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets args that override this arg’s <a href=\"./struct.Arg.html#method.required\">required</a> setting. (i.e. this arg will be required\nunless <em>at least one of</em> these other arguments are present).</p>\n<p><strong>NOTE:</strong> If you wish for this argument to only be required if <em>all of</em> these args are\npresent see <a href=\"./struct.Arg.html#method.required_unless_all\"><code>Arg::required_unless_all</code></a></p>\n<h5 id=\"examples-16\"><a href=\"#examples-16\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .required_unless_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;cfg&quot;</span>, <span class=\"string\">&quot;dbg&quot;</span>])</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.required_unless_one\"><code>Arg::required_unless_one(names)</code></a> requires that the argument be used at runtime\n<em>unless</em> <em>at least one of</em> the args in <code>names</code> are present. In the following example, the\nrequired argument is <em>not</em> provided, but it’s not an error because one the <code>unless</code> args\nhave been supplied.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required_unless_one(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;dbg&quot;</span>, <span class=\"string\">&quot;infile&quot;</span>])\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;dbg&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;infile&quot;</span>)\n        .short(<span class=\"string\">&quot;i&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--debug&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok());</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.required_unless_one\"><code>Arg::required_unless_one(names)</code></a> and <em>not</em> supplying <em>at least one of</em> <code>names</code>\nor this arg is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required_unless_one(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;dbg&quot;</span>, <span class=\"string\">&quot;infile&quot;</span>])\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;dbg&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;infile&quot;</span>)\n        .short(<span class=\"string\">&quot;i&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.conflicts_with\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1150\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.conflicts_with\" class=\"fn\">conflicts_with</a>(self, name: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets a conflicting argument by name. I.e. when using this argument,\nthe following argument can’t be present and vice versa.</p>\n<p><strong>NOTE:</strong> Conflicting rules take precedence over being required by default. Conflict rules\nonly need to be set for one of the two arguments, they do not need to be set for each.</p>\n<p><strong>NOTE:</strong> Defining a conflict is two-way, but does <em>not</em> need to defined for both arguments\n(i.e. if A conflicts with B, defining A.conflicts_with(B) is sufficient. You do not need\nneed to also do B.conflicts_with(A))</p>\n<h5 id=\"examples-17\"><a href=\"#examples-17\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .conflicts_with(<span class=\"string\">&quot;debug&quot;</span>)</code></pre></div>\n<p>Setting conflicting argument, and having both arguments present at runtime is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .conflicts_with(<span class=\"string\">&quot;debug&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--debug&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;file.conf&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::ArgumentConflict);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.conflicts_with_all\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1200\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.conflicts_with_all\" class=\"fn\">conflicts_with_all</a>(self, names: &amp;[&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>The same as <a href=\"./struct.Arg.html#method.conflicts_with\"><code>Arg::conflicts_with</code></a> but allows specifying multiple two-way conlicts per\nargument.</p>\n<p><strong>NOTE:</strong> Conflicting rules take precedence over being required by default. Conflict rules\nonly need to be set for one of the two arguments, they do not need to be set for each.</p>\n<p><strong>NOTE:</strong> Defining a conflict is two-way, but does <em>not</em> need to defined for both arguments\n(i.e. if A conflicts with B, defining A.conflicts_with(B) is sufficient. You do not need\nneed to also do B.conflicts_with(A))</p>\n<h5 id=\"examples-18\"><a href=\"#examples-18\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .conflicts_with_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;debug&quot;</span>, <span class=\"string\">&quot;input&quot;</span>])</code></pre></div>\n<p>Setting conflicting argument, and having any of the arguments present at runtime with a\nconflicting argument is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .conflicts_with_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;debug&quot;</span>, <span class=\"string\">&quot;input&quot;</span>])\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;input&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;file.conf&quot;</span>, <span class=\"string\">&quot;file.txt&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::ArgumentConflict);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.overrides_with\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1309\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.overrides_with\" class=\"fn\">overrides_with</a>(self, name: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets a overridable argument by name. I.e. this argument and the following argument\nwill override each other in POSIX style (whichever argument was specified at runtime\n<strong>last</strong> “wins”)</p>\n<p><strong>NOTE:</strong> When an argument is overridden it is essentially as if it never was used, any\nconflicts, requirements, etc. are evaluated <strong>after</strong> all “overrides” have been removed</p>\n<p><strong>WARNING:</strong> Positional arguments cannot override themselves (or we would never be able\nto advance to the next positional). If a positional agument lists itself as an override,\nit is simply ignored.</p>\n<h5 id=\"examples-19\"><a href=\"#examples-19\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::from_usage(<span class=\"string\">&quot;-f, --flag &#39;some flag&#39;&quot;</span>)\n        .conflicts_with(<span class=\"string\">&quot;debug&quot;</span>))\n    .arg(Arg::from_usage(<span class=\"string\">&quot;-d, --debug &#39;other flag&#39;&quot;</span>))\n    .arg(Arg::from_usage(<span class=\"string\">&quot;-c, --color &#39;third flag&#39;&quot;</span>)\n        .overrides_with(<span class=\"string\">&quot;flag&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;-d&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]);\n            <span class=\"comment\">//    ^~~~~~~~~~~~^~~~~ flag is overridden by color\n\n</span><span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;color&quot;</span>));\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;debug&quot;</span>)); <span class=\"comment\">// even though flag conflicts with debug, it&#39;s as if flag\n                                // was never used because it was overridden with color\n</span><span class=\"macro\">assert!</span>(!m.is_present(<span class=\"string\">&quot;flag&quot;</span>));</code></pre></div>\n<p>Care must be taken when using this setting, and having an arg override with itself. This\nis common practice when supporting things like shell aliases, config files, etc.\nHowever, when combined with multiple values, it can get dicy.\nHere is how clap handles such situations:</p>\n<p>When a flag overrides itself, it’s as if the flag was only ever used once (essentially\npreventing a “Unexpected multiple usage” error):</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;posix&quot;</span>)\n            .arg(Arg::from_usage(<span class=\"string\">&quot;--flag  &#39;some flag&#39;&quot;</span>).overrides_with(<span class=\"string\">&quot;flag&quot;</span>))\n            .get_matches_from(<span class=\"macro\">vec!</span>[<span class=\"string\">&quot;posix&quot;</span>, <span class=\"string\">&quot;--flag&quot;</span>, <span class=\"string\">&quot;--flag&quot;</span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;flag&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;flag&quot;</span>), <span class=\"number\">1</span>);</code></pre></div>\n<p>Making a arg <code>multiple(true)</code> and override itself is essentially meaningless. Therefore\nclap ignores an override of self if it’s a flag and it already accepts multiple occurrences.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;posix&quot;</span>)\n            .arg(Arg::from_usage(<span class=\"string\">&quot;--flag...  &#39;some flag&#39;&quot;</span>).overrides_with(<span class=\"string\">&quot;flag&quot;</span>))\n            .get_matches_from(<span class=\"macro\">vec!</span>[<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;--flag&quot;</span>, <span class=\"string\">&quot;--flag&quot;</span>, <span class=\"string\">&quot;--flag&quot;</span>, <span class=\"string\">&quot;--flag&quot;</span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;flag&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;flag&quot;</span>), <span class=\"number\">4</span>);</code></pre></div>\n<p>Now notice with options (which <em>do not</em> set <code>multiple(true)</code>), it’s as if only the last\noccurrence happened.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;posix&quot;</span>)\n            .arg(Arg::from_usage(<span class=\"string\">&quot;--opt [val] &#39;some option&#39;&quot;</span>).overrides_with(<span class=\"string\">&quot;opt&quot;</span>))\n            .get_matches_from(<span class=\"macro\">vec!</span>[<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;--opt=some&quot;</span>, <span class=\"string\">&quot;--opt=other&quot;</span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;opt&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;opt&quot;</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;opt&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;other&quot;</span>));</code></pre></div>\n<p>Just like flags, options with <code>multiple(true)</code> set, will ignore the “override self” setting.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;posix&quot;</span>)\n            .arg(Arg::from_usage(<span class=\"string\">&quot;--opt [val]... &#39;some option&#39;&quot;</span>)\n                .overrides_with(<span class=\"string\">&quot;opt&quot;</span>))\n            .get_matches_from(<span class=\"macro\">vec!</span>[<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;--opt&quot;</span>, <span class=\"string\">&quot;first&quot;</span>, <span class=\"string\">&quot;over&quot;</span>, <span class=\"string\">&quot;--opt&quot;</span>, <span class=\"string\">&quot;other&quot;</span>, <span class=\"string\">&quot;val&quot;</span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;opt&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;opt&quot;</span>), <span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(m.values_of(<span class=\"string\">&quot;opt&quot;</span>).unwrap().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;first&quot;</span>, <span class=\"string\">&quot;over&quot;</span>, <span class=\"string\">&quot;other&quot;</span>, <span class=\"string\">&quot;val&quot;</span>]);</code></pre></div>\n<p>A safe thing to do if you’d like to support an option which supports multiple values, but\nalso is “overridable” by itself, is to use <code>use_delimiter(false)</code> and <em>not</em> use\n<code>multiple(true)</code> while telling users to seperate values with a comma (i.e. <code>val1,val2</code>)</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;posix&quot;</span>)\n            .arg(Arg::from_usage(<span class=\"string\">&quot;--opt [val] &#39;some option&#39;&quot;</span>)\n                .overrides_with(<span class=\"string\">&quot;opt&quot;</span>)\n                .use_delimiter(<span class=\"bool-val\">false</span>))\n            .get_matches_from(<span class=\"macro\">vec!</span>[<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;--opt=some,other&quot;</span>, <span class=\"string\">&quot;--opt=one,two&quot;</span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;opt&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;opt&quot;</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(m.values_of(<span class=\"string\">&quot;opt&quot;</span>).unwrap().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;one,two&quot;</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.overrides_with_all\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1345\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.overrides_with_all\" class=\"fn\">overrides_with_all</a>(self, names: &amp;[&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets multiple mutually overridable arguments by name. I.e. this argument and the following\nargument will override each other in POSIX style (whichever argument was specified at\nruntime <strong>last</strong> “wins”)</p>\n<p><strong>NOTE:</strong> When an argument is overridden it is essentially as if it never was used, any\nconflicts, requirements, etc. are evaluated <strong>after</strong> all “overrides” have been removed</p>\n<h5 id=\"examples-20\"><a href=\"#examples-20\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::from_usage(<span class=\"string\">&quot;-f, --flag &#39;some flag&#39;&quot;</span>)\n        .conflicts_with(<span class=\"string\">&quot;color&quot;</span>))\n    .arg(Arg::from_usage(<span class=\"string\">&quot;-d, --debug &#39;other flag&#39;&quot;</span>))\n    .arg(Arg::from_usage(<span class=\"string\">&quot;-c, --color &#39;third flag&#39;&quot;</span>)\n        .overrides_with_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;flag&quot;</span>, <span class=\"string\">&quot;debug&quot;</span>]))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-f&quot;</span>, <span class=\"string\">&quot;-d&quot;</span>, <span class=\"string\">&quot;-c&quot;</span>]);\n            <span class=\"comment\">//    ^~~~~~^~~~~~~~~ flag and debug are overridden by color\n\n</span><span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;color&quot;</span>)); <span class=\"comment\">// even though flag conflicts with color, it&#39;s as if flag\n                                // and debug were never used because they were overridden\n                                // with color\n</span><span class=\"macro\">assert!</span>(!m.is_present(<span class=\"string\">&quot;debug&quot;</span>));\n<span class=\"macro\">assert!</span>(!m.is_present(<span class=\"string\">&quot;flag&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.requires\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1411\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.requires\" class=\"fn\">requires</a>(self, name: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets an argument by name that is required when this one is present I.e. when\nusing this argument, the following argument <em>must</em> be present.</p>\n<p><strong>NOTE:</strong> <a href=\"./struct.Arg.html#method.conflicts_with\">Conflicting</a> rules and <a href=\"./struct.Arg.html#method.overrides_with\">override</a> rules take precedence over being required</p>\n<h5 id=\"examples-21\"><a href=\"#examples-21\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .requires(<span class=\"string\">&quot;input&quot;</span>)</code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.requires\"><code>Arg::requires(name)</code></a> requires that the argument be used at runtime if the\ndefining argument is used. If the defining argument isn’t used, the other argument isn’t\nrequired</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .requires(<span class=\"string\">&quot;input&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;input&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok()); <span class=\"comment\">// We didn&#39;t use cfg, so input wasn&#39;t required</span></code></pre></div>\n<p>Setting <a href=\"./struct.Arg.html#method.requires\"><code>Arg::requires(name)</code></a> and <em>not</em> supplying that argument is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .requires(<span class=\"string\">&quot;input&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;input&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;file.conf&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.requires_if\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1479\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.requires_if\" class=\"fn\">requires_if</a>(self, val: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>, arg: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows a conditional requirement. The requirement will only become valid if this arg’s value\nequals <code>val</code>.</p>\n<p><strong>NOTE:</strong> If using YAML the values should be laid out as follows</p>\n<div class=\"example-wrap\"><pre class=\"language-yaml\"><code>requires_if:\n    - [val, arg]\n</code></pre></div><h5 id=\"examples-22\"><a href=\"#examples-22\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .requires_if(<span class=\"string\">&quot;val&quot;</span>, <span class=\"string\">&quot;arg&quot;</span>)</code></pre></div>\n<p>Setting [<code>Arg::requires_if(val, arg)</code>] requires that the <code>arg</code> be used at runtime if the\ndefining argument’s value is equal to <code>val</code>. If the defining argument is anything other than\n<code>val</code>, the other argument isn’t required.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .requires_if(<span class=\"string\">&quot;my.cfg&quot;</span>, <span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;some.cfg&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok()); <span class=\"comment\">// We didn&#39;t use --config=my.cfg, so other wasn&#39;t required</span></code></pre></div>\n<p>Setting [<code>Arg::requires_if(val, arg)</code>] and setting the value to <code>val</code> but <em>not</em> supplying\n<code>arg</code> is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .requires_if(<span class=\"string\">&quot;my.cfg&quot;</span>, <span class=\"string\">&quot;input&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;input&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;my.cfg&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.requires_ifs\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1539\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.requires_ifs\" class=\"fn\">requires_ifs</a>(self, ifs: &amp;[(&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>, &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>)]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows multiple conditional requirements. The requirement will only become valid if this arg’s value\nequals <code>val</code>.</p>\n<p><strong>NOTE:</strong> If using YAML the values should be laid out as follows</p>\n<div class=\"example-wrap\"><pre class=\"language-yaml\"><code>requires_if:\n    - [val, arg]\n    - [val2, arg2]\n</code></pre></div><h5 id=\"examples-23\"><a href=\"#examples-23\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .requires_ifs(<span class=\"kw-2\">&amp;</span>[\n        (<span class=\"string\">&quot;val&quot;</span>, <span class=\"string\">&quot;arg&quot;</span>),\n        (<span class=\"string\">&quot;other_val&quot;</span>, <span class=\"string\">&quot;arg2&quot;</span>),\n    ])</code></pre></div>\n<p>Setting [<code>Arg::requires_ifs(&amp;[&quot;val&quot;, &quot;arg&quot;])</code>] requires that the <code>arg</code> be used at runtime if the\ndefining argument’s value is equal to <code>val</code>. If the defining argument’s value is anything other\nthan <code>val</code>, <code>arg</code> isn’t required.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .requires_ifs(<span class=\"kw-2\">&amp;</span>[\n            (<span class=\"string\">&quot;special.conf&quot;</span>, <span class=\"string\">&quot;opt&quot;</span>),\n            (<span class=\"string\">&quot;other.conf&quot;</span>, <span class=\"string\">&quot;other&quot;</span>),\n        ])\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .long(<span class=\"string\">&quot;option&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;special.conf&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err()); <span class=\"comment\">// We  used --config=special.conf so --option &lt;val&gt; is required\n</span><span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.required_if\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1617\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.required_if\" class=\"fn\">required_if</a>(self, arg: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>, val: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows specifying that an argument is <a href=\"./struct.Arg.html#method.required\">required</a> conditionally. The requirement will only\nbecome valid if the specified <code>arg</code>’s value equals <code>val</code>.</p>\n<p><strong>NOTE:</strong> If using YAML the values should be laid out as follows</p>\n<div class=\"example-wrap\"><pre class=\"language-yaml\"><code>required_if:\n    - [arg, val]\n</code></pre></div><h5 id=\"examples-24\"><a href=\"#examples-24\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .required_if(<span class=\"string\">&quot;other_arg&quot;</span>, <span class=\"string\">&quot;value&quot;</span>)</code></pre></div>\n<p>Setting [<code>Arg::required_if(arg, val)</code>] makes this arg required if the <code>arg</code> is used at\nruntime and it’s value is equal to <code>val</code>. If the <code>arg</code>’s value is anything other than <code>val</code>,\nthis argument isn’t required.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .required_if(<span class=\"string\">&quot;other&quot;</span>, <span class=\"string\">&quot;special&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--other&quot;</span>, <span class=\"string\">&quot;not-special&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok()); <span class=\"comment\">// We didn&#39;t use --other=special, so &quot;cfg&quot; wasn&#39;t required</span></code></pre></div>\n<p>Setting [<code>Arg::required_if(arg, val)</code>] and having <code>arg</code> used with a value of <code>val</code> but <em>not</em>\nusing this arg is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .required_if(<span class=\"string\">&quot;other&quot;</span>, <span class=\"string\">&quot;special&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--other&quot;</span>, <span class=\"string\">&quot;special&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.required_ifs\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1706\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.required_ifs\" class=\"fn\">required_ifs</a>(self, ifs: &amp;[(&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>, &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>)]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows specifying that an argument is <a href=\"./struct.Arg.html#method.required\">required</a> based on multiple conditions. The\nconditions are set up in a <code>(arg, val)</code> style tuple. The requirement will only become valid\nif one of the specified <code>arg</code>’s value equals it’s corresponding <code>val</code>.</p>\n<p><strong>NOTE:</strong> If using YAML the values should be laid out as follows</p>\n<div class=\"example-wrap\"><pre class=\"language-yaml\"><code>required_if:\n    - [arg, val]\n    - [arg2, val2]\n</code></pre></div><h5 id=\"examples-25\"><a href=\"#examples-25\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .required_ifs(<span class=\"kw-2\">&amp;</span>[\n        (<span class=\"string\">&quot;extra&quot;</span>, <span class=\"string\">&quot;val&quot;</span>),\n        (<span class=\"string\">&quot;option&quot;</span>, <span class=\"string\">&quot;spec&quot;</span>)\n    ])</code></pre></div>\n<p>Setting [<code>Arg::required_ifs(&amp;[(arg, val)])</code>] makes this arg required if any of the <code>arg</code>s\nare used at runtime and it’s corresponding value is equal to <code>val</code>. If the <code>arg</code>’s value is\nanything other than <code>val</code>, this argument isn’t required.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required_ifs(<span class=\"kw-2\">&amp;</span>[\n            (<span class=\"string\">&quot;extra&quot;</span>, <span class=\"string\">&quot;val&quot;</span>),\n            (<span class=\"string\">&quot;option&quot;</span>, <span class=\"string\">&quot;spec&quot;</span>)\n        ])\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;extra&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;extra&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;option&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;option&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--option&quot;</span>, <span class=\"string\">&quot;other&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok()); <span class=\"comment\">// We didn&#39;t use --option=spec, or --extra=val so &quot;cfg&quot; isn&#39;t required</span></code></pre></div>\n<p>Setting [<code>Arg::required_ifs(&amp;[(arg, val)])</code>] and having any of the <code>arg</code>s used with it’s\nvalue of <code>val</code> but <em>not</em> using this arg is an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .required_ifs(<span class=\"kw-2\">&amp;</span>[\n            (<span class=\"string\">&quot;extra&quot;</span>, <span class=\"string\">&quot;val&quot;</span>),\n            (<span class=\"string\">&quot;option&quot;</span>, <span class=\"string\">&quot;spec&quot;</span>)\n        ])\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;extra&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;extra&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;option&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;option&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--option&quot;</span>, <span class=\"string\">&quot;spec&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.requires_all\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1783\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.requires_all\" class=\"fn\">requires_all</a>(self, names: &amp;[&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets multiple arguments by names that are required when this one is present I.e. when\nusing this argument, the following arguments <em>must</em> be present.</p>\n<p><strong>NOTE:</strong> <a href=\"./struct.Arg.html#method.conflicts_with\">Conflicting</a> rules and <a href=\"./struct.Arg.html#method.overrides_with\">override</a> rules take precedence over being required\nby default.</p>\n<h5 id=\"examples-26\"><a href=\"#examples-26\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .requires_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;input&quot;</span>, <span class=\"string\">&quot;output&quot;</span>])</code></pre></div>\n<p>Setting [<code>Arg::requires_all(&amp;[arg, arg2])</code>] requires that all the arguments be used at\nruntime if the defining argument is used. If the defining argument isn’t used, the other\nargument isn’t required</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .requires(<span class=\"string\">&quot;input&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;input&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;output&quot;</span>)\n        .index(<span class=\"number\">2</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok()); <span class=\"comment\">// We didn&#39;t use cfg, so input and output weren&#39;t required</span></code></pre></div>\n<p>Setting [<code>Arg::requires_all(&amp;[arg, arg2])</code>] and <em>not</em> supplying all the arguments is an\nerror.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .requires_all(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;input&quot;</span>, <span class=\"string\">&quot;output&quot;</span>])\n        .long(<span class=\"string\">&quot;config&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;input&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;output&quot;</span>)\n        .index(<span class=\"number\">2</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config&quot;</span>, <span class=\"string\">&quot;file.conf&quot;</span>, <span class=\"string\">&quot;in.txt&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"comment\">// We didn&#39;t use output\n</span><span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::MissingRequiredArgument);</code></pre></div>\n<p>[<code>Arg::requires_all(&amp;[arg, arg2])</code>]: ./struct.Arg.html#method.requires_all</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.takes_value\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1836\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.takes_value\" class=\"fn\">takes_value</a>(self, tv: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies that the argument takes a value at run time.</p>\n<p><strong>NOTE:</strong> values for arguments may be specified in any of the following methods</p>\n<ul>\n<li>Using a space such as <code>-o value</code> or <code>--option value</code></li>\n<li>Using an equals and no space such as <code>-o=value</code> or <code>--option=value</code></li>\n<li>Use a short and no space such as <code>-ovalue</code></li>\n</ul>\n<p><strong>NOTE:</strong> By default, args which allow <a href=\"./struct.Arg.html#method.multiple\">multiple values</a> are delimited by commas, meaning\n<code>--option=val1,val2,val3</code> is three values for the <code>--option</code> argument. If you wish to\nchange the delimiter to another character you can use <a href=\"./struct.Arg.html#method.value_delimiter\"><code>Arg::value_delimiter(char)</code></a>,\nalternatively you can turn delimiting values <strong>OFF</strong> by using <a href=\"./struct.Arg.html#method.use_delimiter\"><code>Arg::use_delimiter(false)</code></a></p>\n<h5 id=\"examples-27\"><a href=\"#examples-27\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .takes_value(<span class=\"bool-val\">true</span>)</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n        .long(<span class=\"string\">&quot;mode&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--mode&quot;</span>, <span class=\"string\">&quot;fast&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;mode&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;mode&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;fast&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hide_possible_values\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1872\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.hide_possible_values\" class=\"fn\">hide_possible_values</a>(self, hide: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies if the possible values of an argument should be displayed in the help text or\nnot. Defaults to <code>false</code> (i.e. show possible values)</p>\n<p>This is useful for args with many values, or ones which are explained elsewhere in the\nhelp text.</p>\n<h5 id=\"examples-28\"><a href=\"#examples-28\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .hide_possible_values(<span class=\"bool-val\">true</span>)</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n        .long(<span class=\"string\">&quot;mode&quot;</span>)\n        .possible_values(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;fast&quot;</span>, <span class=\"string\">&quot;slow&quot;</span>])\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .hide_possible_values(<span class=\"bool-val\">true</span>));\n</code></pre></div>\n<p>If we were to run the above program with <code>--help</code> the <code>[values: fast, slow]</code> portion of\nthe help text would be omitted.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hide_default_value\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1906\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.hide_default_value\" class=\"fn\">hide_default_value</a>(self, hide: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies if the default value of an argument should be displayed in the help text or\nnot. Defaults to <code>false</code> (i.e. show default value)</p>\n<p>This is useful when default behavior of an arg is explained elsewhere in the help text.</p>\n<h5 id=\"examples-29\"><a href=\"#examples-29\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .hide_default_value(<span class=\"bool-val\">true</span>)</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;connect&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;host&quot;</span>)\n        .long(<span class=\"string\">&quot;host&quot;</span>)\n        .default_value(<span class=\"string\">&quot;localhost&quot;</span>)\n        .hide_default_value(<span class=\"bool-val\">true</span>));\n</code></pre></div>\n<p>If we were to run the above program with <code>--help</code> the <code>[default: localhost]</code> portion of\nthe help text would be omitted.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#1961\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.index\" class=\"fn\">index</a>(self, idx: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u64.html\">u64</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the index of a positional argument <strong>starting at</strong> 1.</p>\n<p><strong>NOTE:</strong> The index refers to position according to <strong>other positional argument</strong>. It does\nnot define position in the argument list as a whole.</p>\n<p><strong>NOTE:</strong> If no <a href=\"./struct.Arg.html#method.short\"><code>Arg::short</code></a>, or <a href=\"./struct.Arg.html#method.long\"><code>Arg::long</code></a> have been defined, you can optionally\nleave off the <code>index</code> method, and the index will be assigned in order of evaluation.\nUtilizing the <code>index</code> method allows for setting indexes out of order</p>\n<p><strong>NOTE:</strong> When utilized with <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a>, only the <strong>last</strong> positional argument\nmay be defined as multiple (i.e. with the highest index)</p>\n<h5 id=\"panics\"><a href=\"#panics\">Panics</a></h5>\n<p>Although not in this method directly, <a href=\"./struct.App.html\"><code>App</code></a> will <a href=\"https://doc.rust-lang.org/std/macro.panic!.html\"><code>panic!</code></a> if indexes are skipped (such\nas defining <code>index(1)</code> and <code>index(3)</code> but not <code>index(2)</code>, or a positional argument is\ndefined as multiple and is not the highest index</p>\n<h5 id=\"examples-30\"><a href=\"#examples-30\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n    .index(<span class=\"number\">1</span>)</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--debug&quot;</span>, <span class=\"string\">&quot;fast&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;mode&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;mode&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;fast&quot;</span>)); <span class=\"comment\">// notice index(1) means &quot;first positional&quot;\n                                              // *not* first argument</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.multiple\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2157\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.multiple\" class=\"fn\">multiple</a>(self, multi: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies that the argument may appear more than once. For flags, this results\nin the number of occurrences of the flag being recorded. For example <code>-ddd</code> or <code>-d -d -d</code>\nwould count as three occurrences. For options there is a distinct difference in multiple\noccurrences vs multiple values.</p>\n<p>For example, <code>--opt val1 val2</code> is one occurrence, but two values. Whereas\n<code>--opt val1 --opt val2</code> is two occurrences.</p>\n<p><strong>WARNING:</strong></p>\n<p>Setting <code>multiple(true)</code> for an <a href=\"./struct.Arg.html#method.takes_value\">option</a> with no other details, allows multiple values\n<strong>and</strong> multiple occurrences because it isn’t possible to have more occurrences than values\nfor options. Because multiple values are allowed, <code>--option val1 val2 val3</code> is perfectly\nvalid, be careful when designing a CLI where positional arguments are expected after a\noption which accepts multiple values, as <code>clap</code> will continue parsing <em>values</em> until it\nreaches the max or specific number of values defined, or another flag or option.</p>\n<p><strong>Pro Tip</strong>:</p>\n<p>It’s possible to define an option which allows multiple occurrences, but only one value per\noccurrence. To do this use <a href=\"./struct.Arg.html#method.number_of_values\"><code>Arg::number_of_values(1)</code></a> in coordination with\n<a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a>.</p>\n<p><strong>WARNING:</strong></p>\n<p>When using args with <code>multiple(true)</code> on <a href=\"./struct.Arg.html#method.takes_value\">options</a> or <a href=\"./struct.Arg.html#method.index\">positionals</a> (i.e. those args that\naccept values) and <a href=\"./struct.SubCommand.html\">subcommands</a>, one needs to consider the possibility of an argument value\nbeing the same as a valid subcommand. By default <code>clap</code> will parse the argument in question\nas a value <em>only if</em> a value is possible at that moment. Otherwise it will be parsed as a\nsubcommand. In effect, this means using <code>multiple(true)</code> with no additional parameters and\na possible value that coincides with a subcommand name, the subcommand cannot be called\nunless another argument is passed first.</p>\n<p>As an example, consider a CLI with an option <code>--ui-paths=&lt;paths&gt;...</code> and subcommand <code>signer</code></p>\n<p>The following would be parsed as values to <code>--ui-paths</code>.</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>$ program --ui-paths path1 path2 signer\n</code></pre></div>\n<p>This is because <code>--ui-paths</code> accepts multiple values. <code>clap</code> will continue parsing values\nuntil another argument is reached and it knows <code>--ui-paths</code> is done.</p>\n<p>By adding additional parameters to <code>--ui-paths</code> we can solve this issue. Consider adding\n<a href=\"./struct.Arg.html#method.number_of_values\"><code>Arg::number_of_values(1)</code></a> as discussed above. The following are all valid, and <code>signer</code>\nis parsed as both a subcommand and a value in the second case.</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>$ program --ui-paths path1 signer\n$ program --ui-paths path1 --ui-paths signer signer\n</code></pre></div><h5 id=\"examples-31\"><a href=\"#examples-31\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n    .short(<span class=\"string\">&quot;d&quot;</span>)\n    .multiple(<span class=\"bool-val\">true</span>)</code></pre></div>\n<p>An example with flags</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;verbose&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .short(<span class=\"string\">&quot;v&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-v&quot;</span>, <span class=\"string\">&quot;-v&quot;</span>, <span class=\"string\">&quot;-v&quot;    </span><span class=\"comment\">// note, -vvv would have same result\n    </span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;verbose&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;verbose&quot;</span>), <span class=\"number\">3</span>);</code></pre></div>\n<p>An example with options</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;file&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;file&quot;</span>), <span class=\"number\">1</span>); <span class=\"comment\">// notice only one occurrence\n</span><span class=\"kw\">let </span>files: Vec&lt;<span class=\"kw\">_</span>&gt; = m.values_of(<span class=\"string\">&quot;file&quot;</span>).unwrap().collect();\n<span class=\"macro\">assert_eq!</span>(files, [<span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>]);</code></pre></div>\n<p>This is functionally equivalent to the example above</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file3&quot;\n    </span>]);\n<span class=\"kw\">let </span>files: Vec&lt;<span class=\"kw\">_</span>&gt; = m.values_of(<span class=\"string\">&quot;file&quot;</span>).unwrap().collect();\n<span class=\"macro\">assert_eq!</span>(files, [<span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;file&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;file&quot;</span>), <span class=\"number\">3</span>); <span class=\"comment\">// Notice 3 occurrences\n</span><span class=\"kw\">let </span>files: Vec&lt;<span class=\"kw\">_</span>&gt; = m.values_of(<span class=\"string\">&quot;file&quot;</span>).unwrap().collect();\n<span class=\"macro\">assert_eq!</span>(files, [<span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>]);</code></pre></div>\n<p>A common mistake is to define an option which allows multiples, and a positional argument</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;word&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>, <span class=\"string\">&quot;word&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;file&quot;</span>));\n<span class=\"kw\">let </span>files: Vec&lt;<span class=\"kw\">_</span>&gt; = m.values_of(<span class=\"string\">&quot;file&quot;</span>).unwrap().collect();\n<span class=\"macro\">assert_eq!</span>(files, [<span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>, <span class=\"string\">&quot;word&quot;</span>]); <span class=\"comment\">// wait...what?!\n</span><span class=\"macro\">assert!</span>(!m.is_present(<span class=\"string\">&quot;word&quot;</span>)); <span class=\"comment\">// but we clearly used word!</span></code></pre></div>\n<p>The problem is clap doesn’t know when to stop parsing values for “files”. This is further\ncompounded by if we’d said <code>word -F file1 file2</code> it would have worked fine, so it would\nappear to only fail sometimes…not good!</p>\n<p>A solution for the example above is to specify that <code>-F</code> only accepts one value, but is\nallowed to appear multiple times</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .number_of_values(<span class=\"number\">1</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;word&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>, <span class=\"string\">&quot;word&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;file&quot;</span>));\n<span class=\"kw\">let </span>files: Vec&lt;<span class=\"kw\">_</span>&gt; = m.values_of(<span class=\"string\">&quot;file&quot;</span>).unwrap().collect();\n<span class=\"macro\">assert_eq!</span>(files, [<span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;word&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;word&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;word&quot;</span>));</code></pre></div>\n<p>As a final example, notice if we define <a href=\"./struct.Arg.html#method.number_of_values\"><code>Arg::number_of_values(1)</code></a> and try to run the\nproblem example above, it would have been a runtime error with a pretty message to the\nuser :)</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .number_of_values(<span class=\"number\">1</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;word&quot;</span>)\n        .index(<span class=\"number\">1</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>, <span class=\"string\">&quot;word&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::UnknownArgument);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.value_terminator\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2210\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.value_terminator\" class=\"fn\">value_terminator</a>(self, term: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies a value that <em>stops</em> parsing multiple values of a give argument. By default when\none sets <a href=\"./struct.Arg.html#method.multiple\"><code>multiple(true)</code></a> on an argument, clap will continue parsing values for that\nargument until it reaches another valid argument, or one of the other more specific settings\nfor multiple values is used (such as <a href=\"./struct.Arg.html#method.min_values\"><code>min_values</code></a>, <a href=\"./struct.Arg.html#method.max_values\"><code>max_values</code></a> or\n<a href=\"./struct.Arg.html#method.number_of_values\"><code>number_of_values</code></a>).</p>\n<p><strong>NOTE:</strong> This setting only applies to <a href=\"./struct.Arg.html#method.takes_value\">options</a> and <a href=\"./struct.Arg.html#method.index\">positional arguments</a></p>\n<p><strong>NOTE:</strong> When the terminator is passed in on the command line, it is <strong>not</strong> stored as one\nof the values</p>\n<h5 id=\"examples-32\"><a href=\"#examples-32\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;vals&quot;</span>)\n    .takes_value(<span class=\"bool-val\">true</span>)\n    .multiple(<span class=\"bool-val\">true</span>)\n    .value_terminator(<span class=\"string\">&quot;;&quot;</span>)</code></pre></div>\n<p>The following example uses two arguments, a sequence of commands, and the location in which\nto perform them</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cmds&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .allow_hyphen_values(<span class=\"bool-val\">true</span>)\n        .value_terminator(<span class=\"string\">&quot;;&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;location&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;find&quot;</span>, <span class=\"string\">&quot;-type&quot;</span>, <span class=\"string\">&quot;f&quot;</span>, <span class=\"string\">&quot;-name&quot;</span>, <span class=\"string\">&quot;special&quot;</span>, <span class=\"string\">&quot;;&quot;</span>, <span class=\"string\">&quot;/home/clap&quot;\n    </span>]);\n<span class=\"kw\">let </span>cmds: Vec&lt;<span class=\"kw\">_</span>&gt; = m.values_of(<span class=\"string\">&quot;cmds&quot;</span>).unwrap().collect();\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>cmds, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;find&quot;</span>, <span class=\"string\">&quot;-type&quot;</span>, <span class=\"string\">&quot;f&quot;</span>, <span class=\"string\">&quot;-name&quot;</span>, <span class=\"string\">&quot;special&quot;</span>]);\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;location&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;/home/clap&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.global\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2259\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.global\" class=\"fn\">global</a>(self, g: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies that an argument can be matched to all child <a href=\"./struct.SubCommand.html\"><code>SubCommand</code></a>s.</p>\n<p><strong>NOTE:</strong> Global arguments <em>only</em> propagate down, <strong>not</strong> up (to parent commands), however\ntheir values once a user uses them will be propagated back up to parents. In effect, this\nmeans one should <em>define</em> all global arguments at the top level, however it doesn’t matter\nwhere the user <em>uses</em> the global argument.</p>\n<h5 id=\"examples-33\"><a href=\"#examples-33\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n    .short(<span class=\"string\">&quot;d&quot;</span>)\n    .global(<span class=\"bool-val\">true</span>)</code></pre></div>\n<p>For example, assume an application with two subcommands, and you’d like to define a\n<code>--verbose</code> flag that can be called on any of the subcommands and parent, but you don’t\nwant to clutter the source with three duplicate <a href=\"./struct.Arg.html\"><code>Arg</code></a> definitions.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;verb&quot;</span>)\n        .long(<span class=\"string\">&quot;verbose&quot;</span>)\n        .short(<span class=\"string\">&quot;v&quot;</span>)\n        .global(<span class=\"bool-val\">true</span>))\n    .subcommand(SubCommand::with_name(<span class=\"string\">&quot;test&quot;</span>))\n    .subcommand(SubCommand::with_name(<span class=\"string\">&quot;do-stuff&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;do-stuff&quot;</span>, <span class=\"string\">&quot;--verbose&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.subcommand_name(), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;do-stuff&quot;</span>));\n<span class=\"kw\">let </span>sub_m = m.subcommand_matches(<span class=\"string\">&quot;do-stuff&quot;</span>).unwrap();\n<span class=\"macro\">assert!</span>(sub_m.is_present(<span class=\"string\">&quot;verb&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.empty_values\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2301\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.empty_values\" class=\"fn\">empty_values</a>(self, ev: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows an argument to accept explicitly empty values. An empty value must be specified at\nthe command line with an explicit <code>&quot;&quot;</code>, or <code>''</code></p>\n<p><strong>NOTE:</strong> Defaults to <code>true</code> (Explicitly empty values are allowed)</p>\n<p><strong>NOTE:</strong> Implicitly sets <a href=\"./struct.Arg.html#method.takes_value\"><code>Arg::takes_value(true)</code></a> when set to <code>false</code></p>\n<h5 id=\"examples-34\"><a href=\"#examples-34\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n    .long(<span class=\"string\">&quot;file&quot;</span>)\n    .empty_values(<span class=\"bool-val\">false</span>)</code></pre></div>\n<p>The default is to allow empty values, such as <code>--option &quot;&quot;</code> would be an empty value. But\nwe can change to make empty values become an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .short(<span class=\"string\">&quot;v&quot;</span>)\n        .empty_values(<span class=\"bool-val\">false</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config=&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::EmptyValue);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hidden\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2353\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.hidden\" class=\"fn\">hidden</a>(self, h: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Hides an argument from help message output.</p>\n<p><strong>NOTE:</strong> Implicitly sets <a href=\"./struct.Arg.html#method.hidden_short_help\"><code>Arg::hidden_short_help(true)</code></a> and <a href=\"./struct.Arg.html#method.hidden_long_help\"><code>Arg::hidden_long_help(true)</code></a>\nwhen set to true</p>\n<p><strong>NOTE:</strong> This does <strong>not</strong> hide the argument from usage strings on error</p>\n<h5 id=\"examples-35\"><a href=\"#examples-35\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n    .hidden(<span class=\"bool-val\">true</span>)</code></pre></div>\n<p>Setting <code>hidden(true)</code> will hide the argument when displaying help text</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .hidden(<span class=\"bool-val\">true</span>)\n        .help(<span class=\"string\">&quot;Some help text describing the --config arg&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>The above example displays</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>helptest\n\nUSAGE:\n   helptest [FLAGS]\n\nFLAGS:\n-h, --help       Prints help information\n-V, --version    Prints version information\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.possible_values\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2408\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.possible_values\" class=\"fn\">possible_values</a>(self, names: &amp;[&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies a list of possible values for this argument. At runtime, <code>clap</code> verifies that\nonly one of the specified values was used, or fails with an error message.</p>\n<p><strong>NOTE:</strong> This setting only applies to <a href=\"./struct.Arg.html#method.takes_value\">options</a> and <a href=\"./struct.Arg.html#method.index\">positional arguments</a></p>\n<h5 id=\"examples-36\"><a href=\"#examples-36\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n    .takes_value(<span class=\"bool-val\">true</span>)\n    .possible_values(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;fast&quot;</span>, <span class=\"string\">&quot;slow&quot;</span>, <span class=\"string\">&quot;medium&quot;</span>])</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n        .long(<span class=\"string\">&quot;mode&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .possible_values(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;fast&quot;</span>, <span class=\"string\">&quot;slow&quot;</span>, <span class=\"string\">&quot;medium&quot;</span>]))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--mode&quot;</span>, <span class=\"string\">&quot;fast&quot;\n    </span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;mode&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;mode&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;fast&quot;</span>));</code></pre></div>\n<p>The next example shows a failed parse from using a value which wasn’t defined as one of the\npossible values.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n        .long(<span class=\"string\">&quot;mode&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .possible_values(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;fast&quot;</span>, <span class=\"string\">&quot;slow&quot;</span>, <span class=\"string\">&quot;medium&quot;</span>]))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--mode&quot;</span>, <span class=\"string\">&quot;wrong&quot;\n    </span>]);\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::InvalidValue);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.possible_value\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2472\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.possible_value\" class=\"fn\">possible_value</a>(self, name: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies a possible value for this argument, one at a time. At runtime, <code>clap</code> verifies\nthat only one of the specified values was used, or fails with error message.</p>\n<p><strong>NOTE:</strong> This setting only applies to <a href=\"./struct.Arg.html#method.takes_value\">options</a> and <a href=\"./struct.Arg.html#method.index\">positional arguments</a></p>\n<h5 id=\"examples-37\"><a href=\"#examples-37\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n    .takes_value(<span class=\"bool-val\">true</span>)\n    .possible_value(<span class=\"string\">&quot;fast&quot;</span>)\n    .possible_value(<span class=\"string\">&quot;slow&quot;</span>)\n    .possible_value(<span class=\"string\">&quot;medium&quot;</span>)</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n        .long(<span class=\"string\">&quot;mode&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .possible_value(<span class=\"string\">&quot;fast&quot;</span>)\n        .possible_value(<span class=\"string\">&quot;slow&quot;</span>)\n        .possible_value(<span class=\"string\">&quot;medium&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--mode&quot;</span>, <span class=\"string\">&quot;fast&quot;\n    </span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;mode&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;mode&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;fast&quot;</span>));</code></pre></div>\n<p>The next example shows a failed parse from using a value which wasn’t defined as one of the\npossible values.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;mode&quot;</span>)\n        .long(<span class=\"string\">&quot;mode&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .possible_value(<span class=\"string\">&quot;fast&quot;</span>)\n        .possible_value(<span class=\"string\">&quot;slow&quot;</span>)\n        .possible_value(<span class=\"string\">&quot;medium&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--mode&quot;</span>, <span class=\"string\">&quot;wrong&quot;\n    </span>]);\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::InvalidValue);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.case_insensitive\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2526\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.case_insensitive\" class=\"fn\">case_insensitive</a>(self, ci: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>When used with <a href=\"clap/args/arg/struct.Arg.html#method.possible_values\" title=\"method clap::args::arg::Arg::possible_values\"><code>Arg::possible_values</code></a> it allows the argument value to pass validation even if\nthe case differs from that of the specified <code>possible_value</code>.</p>\n<p><strong>Pro Tip:</strong> Use this setting with <a href=\"./macro.arg_enum.html\"><code>arg_enum!</code></a></p>\n<h5 id=\"examples-38\"><a href=\"#examples-38\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;pv&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;option&quot;</span>)\n        .long(<span class=\"string\">&quot;--option&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .possible_value(<span class=\"string\">&quot;test123&quot;</span>)\n        .case_insensitive(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;pv&quot;</span>, <span class=\"string\">&quot;--option&quot;</span>, <span class=\"string\">&quot;TeSt123&quot;</span>,\n    ]);\n\n<span class=\"macro\">assert!</span>(m.value_of(<span class=\"string\">&quot;option&quot;</span>).unwrap().eq_ignore_ascii_case(<span class=\"string\">&quot;test123&quot;</span>));</code></pre></div>\n<p>This setting also works when multiple values can be defined:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;pv&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;option&quot;</span>)\n        .short(<span class=\"string\">&quot;-o&quot;</span>)\n        .long(<span class=\"string\">&quot;--option&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .possible_value(<span class=\"string\">&quot;test123&quot;</span>)\n        .possible_value(<span class=\"string\">&quot;test321&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .case_insensitive(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;pv&quot;</span>, <span class=\"string\">&quot;--option&quot;</span>, <span class=\"string\">&quot;TeSt123&quot;</span>, <span class=\"string\">&quot;teST123&quot;</span>, <span class=\"string\">&quot;tESt321&quot;\n    </span>]);\n\n<span class=\"kw\">let </span>matched_vals = m.values_of(<span class=\"string\">&quot;option&quot;</span>).unwrap().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;();\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;*</span>matched_vals, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;TeSt123&quot;</span>, <span class=\"string\">&quot;teST123&quot;</span>, <span class=\"string\">&quot;tESt321&quot;</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.group\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2564\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.group\" class=\"fn\">group</a>(self, name: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the name of the <a href=\"./struct.ArgGroup.html\"><code>ArgGroup</code></a> the argument belongs to.</p>\n<h5 id=\"examples-39\"><a href=\"#examples-39\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n    .long(<span class=\"string\">&quot;debug&quot;</span>)\n    .group(<span class=\"string\">&quot;mode&quot;</span>)</code></pre></div>\n<p>Multiple arguments can be a member of a single group and then the group checked as if it\nwas one of said arguments.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>)\n        .group(<span class=\"string\">&quot;mode&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;verbose&quot;</span>)\n        .long(<span class=\"string\">&quot;verbose&quot;</span>)\n        .group(<span class=\"string\">&quot;mode&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--debug&quot;\n    </span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;mode&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.groups\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2604\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.groups\" class=\"fn\">groups</a>(self, names: &amp;[&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the names of multiple <a href=\"./struct.ArgGroup.html\"><code>ArgGroup</code></a>’s the argument belongs to.</p>\n<h5 id=\"examples-40\"><a href=\"#examples-40\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n    .long(<span class=\"string\">&quot;debug&quot;</span>)\n    .groups(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;mode&quot;</span>, <span class=\"string\">&quot;verbosity&quot;</span>])</code></pre></div>\n<p>Arguments can be members of multiple groups and then the group checked as if it\nwas one of said arguments.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n        .long(<span class=\"string\">&quot;debug&quot;</span>)\n        .groups(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;mode&quot;</span>, <span class=\"string\">&quot;verbosity&quot;</span>]))\n    .arg(Arg::with_name(<span class=\"string\">&quot;verbose&quot;</span>)\n        .long(<span class=\"string\">&quot;verbose&quot;</span>)\n        .groups(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;mode&quot;</span>, <span class=\"string\">&quot;verbosity&quot;</span>]))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--debug&quot;\n    </span>]);\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;mode&quot;</span>));\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;verbosity&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.number_of_values\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2651\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.number_of_values\" class=\"fn\">number_of_values</a>(self, qty: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u64.html\">u64</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies how many values are required to satisfy this argument. For example, if you had a\n<code>-f &lt;file&gt;</code> argument where you wanted exactly 3 ‘files’ you would set\n<code>.number_of_values(3)</code>, and this argument wouldn’t be satisfied unless the user provided\n3 and only 3 values.</p>\n<p><strong>NOTE:</strong> Does <em>not</em> require <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a> to be set. Setting\n<a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a> would allow <code>-f &lt;file&gt; &lt;file&gt; &lt;file&gt; -f &lt;file&gt; &lt;file&gt; &lt;file&gt;</code> where\nas <em>not</em> setting <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a> would only allow one occurrence of this argument.</p>\n<h5 id=\"examples-41\"><a href=\"#examples-41\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n    .short(<span class=\"string\">&quot;f&quot;</span>)\n    .number_of_values(<span class=\"number\">3</span>)</code></pre></div>\n<p>Not supplying the correct number of values is an error</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .number_of_values(<span class=\"number\">2</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::WrongNumberOfValues);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.validator\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2693-2695\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.validator\" class=\"fn\">validator</a>&lt;F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;<span class=\"where fmt-newline\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html\" title=\"trait core::ops::function::Fn\">Fn</a>(<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a>&gt; + 'static,</span></h4></section></summary><div class=\"docblock\"><p>Allows one to perform a custom validation on the argument value. You provide a closure\nwhich accepts a <a href=\"https://doc.rust-lang.org/std/string/struct.String.html\"><code>String</code></a> value, and return a <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\"><code>Result</code></a> where the <a href=\"https://doc.rust-lang.org/std/result/enum.Result.html#variant.Err\"><code>Err(String)</code></a> is a\nmessage displayed to the user.</p>\n<p><strong>NOTE:</strong> The error message does <em>not</em> need to contain the <code>error:</code> portion, only the\nmessage as all errors will appear as\n<code>error: Invalid value for '&lt;arg&gt;': &lt;YOUR MESSAGE&gt;</code> where <code>&lt;arg&gt;</code> is replaced by the actual\narg, and <code>&lt;YOUR MESSAGE&gt;</code> is the <code>String</code> you return as the error.</p>\n<p><strong>NOTE:</strong> There is a small performance hit for using validators, as they are implemented\nwith <a href=\"https://doc.rust-lang.org/std/rc/struct.Rc.html\"><code>Rc</code></a> pointers. And the value to be checked will be allocated an extra time in order\nto to be passed to the closure. This performance hit is extremely minimal in the grand\nscheme of things.</p>\n<h5 id=\"examples-42\"><a href=\"#examples-42\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>has_at(v: String) -&gt; <span class=\"prelude-ty\">Result</span>&lt;(), String&gt; {\n    <span class=\"kw\">if </span>v.contains(<span class=\"string\">&quot;@&quot;</span>) { <span class=\"kw\">return </span><span class=\"prelude-val\">Ok</span>(()); }\n    <span class=\"prelude-val\">Err</span>(String::from(<span class=\"string\">&quot;The value did not contain the required @ sigil&quot;</span>))\n}\n<span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .index(<span class=\"number\">1</span>)\n        .validator(has_at))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;some@file&quot;\n    </span>]);\n<span class=\"macro\">assert!</span>(res.is_ok());\n<span class=\"macro\">assert_eq!</span>(res.unwrap().value_of(<span class=\"string\">&quot;file&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;some@file&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.validator_os\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2731-2733\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.validator_os\" class=\"fn\">validator_os</a>&lt;F&gt;(self, f: F) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;<span class=\"where fmt-newline\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html\" title=\"trait core::ops::function::Fn\">Fn</a>(&amp;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsString.html\" title=\"struct std::ffi::os_str::OsString\">OsString</a>&gt; + 'static,</span></h4></section></summary><div class=\"docblock\"><p>Works identically to Validator but is intended to be used with values that could\ncontain non UTF-8 formatted strings.</p>\n<h5 id=\"examples-43\"><a href=\"#examples-43\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">fn </span>has_ampersand(v: <span class=\"kw-2\">&amp;</span>OsStr) -&gt; <span class=\"prelude-ty\">Result</span>&lt;(), OsString&gt; {\n   <span class=\"kw\">if </span>v.as_bytes().iter().any(|b| <span class=\"kw-2\">*</span>b == <span class=\"string\">b&#39;&amp;&#39;</span>) { <span class=\"kw\">return </span><span class=\"prelude-val\">Ok</span>(()); }\n   <span class=\"prelude-val\">Err</span>(OsString::from(<span class=\"string\">&quot;The value did not contain the required &amp; sigil&quot;</span>))\n}\n<span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n   .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n       .index(<span class=\"number\">1</span>)\n       .validator_os(has_ampersand))\n   .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n       <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;Fish &amp; chips&quot;\n   </span>]);\n<span class=\"macro\">assert!</span>(res.is_ok());\n<span class=\"macro\">assert_eq!</span>(res.unwrap().value_of(<span class=\"string\">&quot;file&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;Fish &amp; chips&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.max_values\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2795\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.max_values\" class=\"fn\">max_values</a>(self, qty: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u64.html\">u64</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the <em>maximum</em> number of values are for this argument. For example, if you had a\n<code>-f &lt;file&gt;</code> argument where you wanted up to 3 ‘files’ you would set <code>.max_values(3)</code>, and\nthis argument would be satisfied if the user provided, 1, 2, or 3 values.</p>\n<p><strong>NOTE:</strong> This does <em>not</em> implicitly set <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a>. This is because\n<code>-o val -o val</code> is multiple occurrences but a single value and <code>-o val1 val2</code> is a single\noccurrence with multiple values. For positional arguments this <strong>does</strong> set\n<a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a> because there is no way to determine the difference between multiple\noccurrences and multiple values.</p>\n<h5 id=\"examples-44\"><a href=\"#examples-44\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n    .short(<span class=\"string\">&quot;f&quot;</span>)\n    .max_values(<span class=\"number\">3</span>)</code></pre></div>\n<p>Supplying less than the maximum number of values is allowed</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .max_values(<span class=\"number\">3</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok());\n<span class=\"kw\">let </span>m = res.unwrap();\n<span class=\"kw\">let </span>files: Vec&lt;<span class=\"kw\">_</span>&gt; = m.values_of(<span class=\"string\">&quot;file&quot;</span>).unwrap().collect();\n<span class=\"macro\">assert_eq!</span>(files, [<span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>]);</code></pre></div>\n<p>Supplying more than the maximum number of values is an error</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .max_values(<span class=\"number\">2</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::TooManyValues);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.min_values\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2858\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.min_values\" class=\"fn\">min_values</a>(self, qty: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u64.html\">u64</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the <em>minimum</em> number of values for this argument. For example, if you had a\n<code>-f &lt;file&gt;</code> argument where you wanted at least 2 ‘files’ you would set\n<code>.min_values(2)</code>, and this argument would be satisfied if the user provided, 2 or more\nvalues.</p>\n<p><strong>NOTE:</strong> This does not implicitly set <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a>. This is because\n<code>-o val -o val</code> is multiple occurrences but a single value and <code>-o val1 val2</code> is a single\noccurrence with multiple values. For positional arguments this <strong>does</strong> set\n<a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a> because there is no way to determine the difference between multiple\noccurrences and multiple values.</p>\n<h5 id=\"examples-45\"><a href=\"#examples-45\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n    .short(<span class=\"string\">&quot;f&quot;</span>)\n    .min_values(<span class=\"number\">3</span>)</code></pre></div>\n<p>Supplying more than the minimum number of values is allowed</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .min_values(<span class=\"number\">2</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_ok());\n<span class=\"kw\">let </span>m = res.unwrap();\n<span class=\"kw\">let </span>files: Vec&lt;<span class=\"kw\">_</span>&gt; = m.values_of(<span class=\"string\">&quot;file&quot;</span>).unwrap().collect();\n<span class=\"macro\">assert_eq!</span>(files, [<span class=\"string\">&quot;file1&quot;</span>, <span class=\"string\">&quot;file2&quot;</span>, <span class=\"string\">&quot;file3&quot;</span>]);</code></pre></div>\n<p>Supplying less than the minimum number of values is an error</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;file&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .min_values(<span class=\"number\">2</span>)\n        .short(<span class=\"string\">&quot;F&quot;</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-F&quot;</span>, <span class=\"string\">&quot;file1&quot;\n    </span>]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"macro\">assert_eq!</span>(res.unwrap_err().kind, ErrorKind::TooFewValues);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.use_delimiter\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2909\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.use_delimiter\" class=\"fn\">use_delimiter</a>(self, d: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies whether or not an argument should allow grouping of multiple values via a\ndelimiter. I.e. should <code>--option=val1,val2,val3</code> be parsed as three values (<code>val1</code>, <code>val2</code>,\nand <code>val3</code>) or as a single value (<code>val1,val2,val3</code>). Defaults to using <code>,</code> (comma) as the\nvalue delimiter for all arguments that accept values (options and positional arguments)</p>\n<p><strong>NOTE:</strong> The default is <code>false</code>. When set to <code>true</code> the default <a href=\"./struct.Arg.html#method.value_delimiter\"><code>Arg::value_delimiter</code></a>\nis the comma <code>,</code>.</p>\n<h5 id=\"examples-46\"><a href=\"#examples-46\">Examples</a></h5>\n<p>The following example shows the default behavior.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>delims = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;option&quot;</span>)\n        .long(<span class=\"string\">&quot;option&quot;</span>)\n        .use_delimiter(<span class=\"bool-val\">true</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--option=val1,val2,val3&quot;</span>,\n    ]);\n\n<span class=\"macro\">assert!</span>(delims.is_present(<span class=\"string\">&quot;option&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(delims.occurrences_of(<span class=\"string\">&quot;option&quot;</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(delims.values_of(<span class=\"string\">&quot;option&quot;</span>).unwrap().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), [<span class=\"string\">&quot;val1&quot;</span>, <span class=\"string\">&quot;val2&quot;</span>, <span class=\"string\">&quot;val3&quot;</span>]);</code></pre></div>\n<p>The next example shows the difference when turning delimiters off. This is the default\nbehavior</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>nodelims = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;option&quot;</span>)\n        .long(<span class=\"string\">&quot;option&quot;</span>)\n        .use_delimiter(<span class=\"bool-val\">false</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--option=val1,val2,val3&quot;</span>,\n    ]);\n\n<span class=\"macro\">assert!</span>(nodelims.is_present(<span class=\"string\">&quot;option&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(nodelims.occurrences_of(<span class=\"string\">&quot;option&quot;</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(nodelims.value_of(<span class=\"string\">&quot;option&quot;</span>).unwrap(), <span class=\"string\">&quot;val1,val2,val3&quot;</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.require_delimiter\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#2995\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.require_delimiter\" class=\"fn\">require_delimiter</a>(self, d: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies that <em>multiple values</em> may only be set using the delimiter. This means if an\nif an option is encountered, and no delimiter is found, it automatically assumed that no\nadditional values for that option follow. This is unlike the default, where it is generally\nassumed that more values will follow regardless of whether or not a delimiter is used.</p>\n<p><strong>NOTE:</strong> The default is <code>false</code>.</p>\n<p><strong>NOTE:</strong> Setting this to true implies <a href=\"./struct.Arg.html#method.use_delimiter\"><code>Arg::use_delimiter(true)</code></a></p>\n<p><strong>NOTE:</strong> It’s a good idea to inform the user that use of a delimiter is required, either\nthrough help text or other means.</p>\n<h5 id=\"examples-47\"><a href=\"#examples-47\">Examples</a></h5>\n<p>These examples demonstrate what happens when <code>require_delimiter(true)</code> is used. Notice\neverything works in this first example, as we use a delimiter, as expected.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>delims = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .short(<span class=\"string\">&quot;o&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .require_delimiter(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-o&quot;</span>, <span class=\"string\">&quot;val1,val2,val3&quot;</span>,\n    ]);\n\n<span class=\"macro\">assert!</span>(delims.is_present(<span class=\"string\">&quot;opt&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(delims.values_of(<span class=\"string\">&quot;opt&quot;</span>).unwrap().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), [<span class=\"string\">&quot;val1&quot;</span>, <span class=\"string\">&quot;val2&quot;</span>, <span class=\"string\">&quot;val3&quot;</span>]);</code></pre></div>\n<p>In this next example, we will <em>not</em> use a delimiter. Notice it’s now an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>res = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .short(<span class=\"string\">&quot;o&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .require_delimiter(<span class=\"bool-val\">true</span>))\n    .get_matches_from_safe(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-o&quot;</span>, <span class=\"string\">&quot;val1&quot;</span>, <span class=\"string\">&quot;val2&quot;</span>, <span class=\"string\">&quot;val3&quot;</span>,\n    ]);\n\n<span class=\"macro\">assert!</span>(res.is_err());\n<span class=\"kw\">let </span>err = res.unwrap_err();\n<span class=\"macro\">assert_eq!</span>(err.kind, ErrorKind::UnknownArgument);</code></pre></div>\n<p>What’s happening is <code>-o</code> is getting <code>val1</code>, and because delimiters are required yet none\nwere present, it stops parsing <code>-o</code>. At this point it reaches <code>val2</code> and because no\npositional arguments have been defined, it’s an error of an unexpected argument.</p>\n<p>In this final example, we contrast the above with <code>clap</code>’s default behavior where the above\nis <em>not</em> an error.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>delims = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .short(<span class=\"string\">&quot;o&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .multiple(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-o&quot;</span>, <span class=\"string\">&quot;val1&quot;</span>, <span class=\"string\">&quot;val2&quot;</span>, <span class=\"string\">&quot;val3&quot;</span>,\n    ]);\n\n<span class=\"macro\">assert!</span>(delims.is_present(<span class=\"string\">&quot;opt&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(delims.values_of(<span class=\"string\">&quot;opt&quot;</span>).unwrap().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), [<span class=\"string\">&quot;val1&quot;</span>, <span class=\"string\">&quot;val2&quot;</span>, <span class=\"string\">&quot;val3&quot;</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.value_delimiter\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3031\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.value_delimiter\" class=\"fn\">value_delimiter</a>(self, d: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the separator to use when values are clumped together, defaults to <code>,</code> (comma).</p>\n<p><strong>NOTE:</strong> implicitly sets <a href=\"./struct.Arg.html#method.use_delimiter\"><code>Arg::use_delimiter(true)</code></a></p>\n<p><strong>NOTE:</strong> implicitly sets <a href=\"./struct.Arg.html#method.takes_value\"><code>Arg::takes_value(true)</code></a></p>\n<h5 id=\"examples-48\"><a href=\"#examples-48\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n        .short(<span class=\"string\">&quot;c&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .value_delimiter(<span class=\"string\">&quot;;&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--config=val1;val2;val3&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.values_of(<span class=\"string\">&quot;config&quot;</span>).unwrap().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), [<span class=\"string\">&quot;val1&quot;</span>, <span class=\"string\">&quot;val2&quot;</span>, <span class=\"string\">&quot;val3&quot;</span>])</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.value_names\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3102\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.value_names\" class=\"fn\">value_names</a>(self, names: &amp;[&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>]) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specify multiple names for values of option arguments. These names are cosmetic only, used\nfor help and usage strings only. The names are <strong>not</strong> used to access arguments. The values\nof the arguments are accessed in numeric order (i.e. if you specify two names <code>one</code> and\n<code>two</code> <code>one</code> will be the first matched value, <code>two</code> will be the second).</p>\n<p>This setting can be very helpful when describing the type of input the user should be\nusing, such as <code>FILE</code>, <code>INTERFACE</code>, etc. Although not required, it’s somewhat convention to\nuse all capital letters for the value name.</p>\n<p><strong>Pro Tip:</strong> It may help to use <a href=\"./struct.Arg.html#method.next_line_help\"><code>Arg::next_line_help(true)</code></a> if there are long, or\nmultiple value names in order to not throw off the help text alignment of all options.</p>\n<p><strong>NOTE:</strong> This implicitly sets <a href=\"./struct.Arg.html#method.number_of_values\"><code>Arg::number_of_values</code></a> if the number of value names is\ngreater than one. I.e. be aware that the number of “names” you set for the values, will be\nthe <em>exact</em> number of values required to satisfy this argument</p>\n<p><strong>NOTE:</strong> implicitly sets <a href=\"./struct.Arg.html#method.takes_value\"><code>Arg::takes_value(true)</code></a></p>\n<p><strong>NOTE:</strong> Does <em>not</em> require or imply <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a>.</p>\n<h5 id=\"examples-49\"><a href=\"#examples-49\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;speed&quot;</span>)\n    .short(<span class=\"string\">&quot;s&quot;</span>)\n    .value_names(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;fast&quot;</span>, <span class=\"string\">&quot;slow&quot;</span>])</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;io&quot;</span>)\n        .long(<span class=\"string\">&quot;io-files&quot;</span>)\n        .value_names(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;INFILE&quot;</span>, <span class=\"string\">&quot;OUTFILE&quot;</span>]))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>Running the above program produces the following output</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>valnames\n\nUSAGE:\n   valnames [FLAGS] [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    --io-files &lt;INFILE&gt; &lt;OUTFILE&gt;    Some help text\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.value_name\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3170\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.value_name\" class=\"fn\">value_name</a>(self, name: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the name for value of <a href=\"./struct.Arg.html#method.takes_value\">option</a> or <a href=\"./struct.Arg.html#method.index\">positional</a> arguments inside of help\ndocumentation. This name is cosmetic only, the name is <strong>not</strong> used to access arguments.\nThis setting can be very helpful when describing the type of input the user should be\nusing, such as <code>FILE</code>, <code>INTERFACE</code>, etc. Although not required, it’s somewhat convention to\nuse all capital letters for the value name.</p>\n<p><strong>NOTE:</strong> implicitly sets <a href=\"./struct.Arg.html#method.takes_value\"><code>Arg::takes_value(true)</code></a></p>\n<h5 id=\"examples-50\"><a href=\"#examples-50\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n    .long(<span class=\"string\">&quot;config&quot;</span>)\n    .value_name(<span class=\"string\">&quot;FILE&quot;</span>)</code></pre></div>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;config&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .value_name(<span class=\"string\">&quot;FILE&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>Running the above program produces the following output</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>valnames\n\nUSAGE:\n   valnames [FLAGS] [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    --config &lt;FILE&gt;     Some help text\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.default_value\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3246\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.default_value\" class=\"fn\">default_value</a>(self, val: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the value of the argument when <em>not</em> specified at runtime.</p>\n<p><strong>NOTE:</strong> If the user <em>does not</em> use this argument at runtime, <a href=\"./struct.ArgMatches.html#method.occurrences_of\"><code>ArgMatches::occurrences_of</code></a>\nwill return <code>0</code> even though the <a href=\"./struct.ArgMatches.html#method.value_of\"><code>ArgMatches::value_of</code></a> will return the default specified.</p>\n<p><strong>NOTE:</strong> If the user <em>does not</em> use this argument at runtime <a href=\"./struct.ArgMatches.html#method.is_present\"><code>ArgMatches::is_present</code></a> will\nstill return <code>true</code>. If you wish to determine whether the argument was used at runtime or\nnot, consider <a href=\"./struct.ArgMatches.html#method.occurrences_of\"><code>ArgMatches::occurrences_of</code></a> which will return <code>0</code> if the argument was <em>not</em>\nused at runtime.</p>\n<p><strong>NOTE:</strong> This setting is perfectly compatible with <a href=\"./struct.Arg.html#method.default_value_if\"><code>Arg::default_value_if</code></a> but slightly\ndifferent. <code>Arg::default_value</code> <em>only</em> takes affect when the user has not provided this arg\nat runtime. <code>Arg::default_value_if</code> however only takes affect when the user has not provided\na value at runtime <strong>and</strong> these other conditions are met as well. If you have set\n<code>Arg::default_value</code> and <code>Arg::default_value_if</code>, and the user <strong>did not</strong> provide a this\narg at runtime, nor did were the conditions met for <code>Arg::default_value_if</code>, the\n<code>Arg::default_value</code> will be applied.</p>\n<p><strong>NOTE:</strong> This implicitly sets <a href=\"./struct.Arg.html#method.takes_value\"><code>Arg::takes_value(true)</code></a>.</p>\n<p><strong>NOTE:</strong> This setting effectively disables <code>AppSettings::ArgRequiredElseHelp</code> if used in\nconjunction as it ensures that some argument will always be present.</p>\n<h5 id=\"examples-51\"><a href=\"#examples-51\">Examples</a></h5>\n<p>First we use the default value without providing any value at runtime.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .long(<span class=\"string\">&quot;myopt&quot;</span>)\n        .default_value(<span class=\"string\">&quot;myval&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;opt&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;myval&quot;</span>));\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;opt&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;opt&quot;</span>), <span class=\"number\">0</span>);</code></pre></div>\n<p>Next we provide a value at runtime to override the default.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .long(<span class=\"string\">&quot;myopt&quot;</span>)\n        .default_value(<span class=\"string\">&quot;myval&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--myopt=non_default&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;opt&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;non_default&quot;</span>));\n<span class=\"macro\">assert!</span>(m.is_present(<span class=\"string\">&quot;opt&quot;</span>));\n<span class=\"macro\">assert_eq!</span>(m.occurrences_of(<span class=\"string\">&quot;opt&quot;</span>), <span class=\"number\">1</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.default_value_os\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3254\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.default_value_os\" class=\"fn\">default_value_os</a>(self, val: &amp;'a <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Provides a default value in the exact same manner as <a href=\"clap/args/arg/struct.Arg.html#method.default_value\" title=\"method clap::args::arg::Arg::default_value\"><code>Arg::default_value</code></a>\nonly using <a href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\"><code>OsStr</code></a>s instead.\n<a href=\"clap/args/arg/struct.Arg.html#method.default_value\" title=\"method clap::args::arg::Arg::default_value\"><code>Arg::default_value</code></a>: ./struct.Arg.html#method.default_value\n<a href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\"><code>OsStr</code></a>: https://doc.rust-lang.org/std/ffi/struct.OsStr.html</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.default_value_if\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3356\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.default_value_if\" class=\"fn\">default_value_if</a>(\n    self,\n    arg: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>,\n    val: <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>&gt;,\n    default: &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>\n) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies the value of the argument if <code>arg</code> has been used at runtime. If <code>val</code> is set to\n<code>None</code>, <code>arg</code> only needs to be present. If <code>val</code> is set to <code>&quot;some-val&quot;</code> then <code>arg</code> must be\npresent at runtime <strong>and</strong> have the value <code>val</code>.</p>\n<p><strong>NOTE:</strong> This setting is perfectly compatible with <a href=\"./struct.Arg.html#method.default_value\"><code>Arg::default_value</code></a> but slightly\ndifferent. <code>Arg::default_value</code> <em>only</em> takes affect when the user has not provided this arg\nat runtime. This setting however only takes affect when the user has not provided a value at\nruntime <strong>and</strong> these other conditions are met as well. If you have set <code>Arg::default_value</code>\nand <code>Arg::default_value_if</code>, and the user <strong>did not</strong> provide a this arg at runtime, nor did\nwere the conditions met for <code>Arg::default_value_if</code>, the <code>Arg::default_value</code> will be\napplied.</p>\n<p><strong>NOTE:</strong> This implicitly sets <a href=\"./struct.Arg.html#method.takes_value\"><code>Arg::takes_value(true)</code></a>.</p>\n<p><strong>NOTE:</strong> If using YAML the values should be laid out as follows (<code>None</code> can be represented\nas <code>null</code> in YAML)</p>\n<div class=\"example-wrap\"><pre class=\"language-yaml\"><code>default_value_if:\n    - [arg, val, default]\n</code></pre></div><h5 id=\"examples-52\"><a href=\"#examples-52\">Examples</a></h5>\n<p>First we use the default value only if another arg is present at runtime.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .default_value_if(<span class=\"string\">&quot;flag&quot;</span>, <span class=\"prelude-val\">None</span>, <span class=\"string\">&quot;default&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--flag&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;other&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;default&quot;</span>));</code></pre></div>\n<p>Next we run the same test, but without providing <code>--flag</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .default_value_if(<span class=\"string\">&quot;flag&quot;</span>, <span class=\"prelude-val\">None</span>, <span class=\"string\">&quot;default&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;other&quot;</span>), <span class=\"prelude-val\">None</span>);</code></pre></div>\n<p>Now lets only use the default value if <code>--opt</code> contains the value <code>special</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;opt&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .default_value_if(<span class=\"string\">&quot;opt&quot;</span>, <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;special&quot;</span>), <span class=\"string\">&quot;default&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--opt&quot;</span>, <span class=\"string\">&quot;special&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;other&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;default&quot;</span>));</code></pre></div>\n<p>We can run the same test and provide any value <em>other than</em> <code>special</code> and we won’t get a\ndefault value.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .long(<span class=\"string\">&quot;opt&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .default_value_if(<span class=\"string\">&quot;opt&quot;</span>, <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;special&quot;</span>), <span class=\"string\">&quot;default&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--opt&quot;</span>, <span class=\"string\">&quot;hahaha&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;other&quot;</span>), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.default_value_if_os\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3368-3373\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.default_value_if_os\" class=\"fn\">default_value_if_os</a>(\n    self,\n    arg: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>,\n    val: <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;'b <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>&gt;,\n    default: &amp;'b <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>\n) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Provides a conditional default value in the exact same manner as <a href=\"clap/args/arg/struct.Arg.html#method.default_value_if\" title=\"method clap::args::arg::Arg::default_value_if\"><code>Arg::default_value_if</code></a>\nonly using <a href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\"><code>OsStr</code></a>s instead.\n<a href=\"clap/args/arg/struct.Arg.html#method.default_value_if\" title=\"method clap::args::arg::Arg::default_value_if\"><code>Arg::default_value_if</code></a>: ./struct.Arg.html#method.default_value_if\n<a href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\"><code>OsStr</code></a>: https://doc.rust-lang.org/std/ffi/struct.OsStr.html</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.default_value_ifs\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3470\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.default_value_ifs\" class=\"fn\">default_value_ifs</a>(\n    self,\n    ifs: &amp;[(&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>, <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>&gt;, &amp;'b <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>)]\n) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies multiple values and conditions in the same manner as <a href=\"clap/args/arg/struct.Arg.html#method.default_value_if\" title=\"method clap::args::arg::Arg::default_value_if\"><code>Arg::default_value_if</code></a>.\nThe method takes a slice of tuples in the <code>(arg, Option&lt;val&gt;, default)</code> format.</p>\n<p><strong>NOTE</strong>: The conditions are stored in order and evaluated in the same order. I.e. the first\nif multiple conditions are true, the first one found will be applied and the ultimate value.</p>\n<p><strong>NOTE:</strong> If using YAML the values should be laid out as follows</p>\n<div class=\"example-wrap\"><pre class=\"language-yaml\"><code>default_value_if:\n    - [arg, val, default]\n    - [arg2, null, default2]\n</code></pre></div><h5 id=\"examples-53\"><a href=\"#examples-53\">Examples</a></h5>\n<p>First we use the default value only if another arg is present at runtime.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .long(<span class=\"string\">&quot;opt&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .default_value_ifs(<span class=\"kw-2\">&amp;</span>[\n            (<span class=\"string\">&quot;flag&quot;</span>, <span class=\"prelude-val\">None</span>, <span class=\"string\">&quot;default&quot;</span>),\n            (<span class=\"string\">&quot;opt&quot;</span>, <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;channal&quot;</span>), <span class=\"string\">&quot;chan&quot;</span>),\n        ]))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--opt&quot;</span>, <span class=\"string\">&quot;channal&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;other&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;chan&quot;</span>));</code></pre></div>\n<p>Next we run the same test, but without providing <code>--flag</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .default_value_ifs(<span class=\"kw-2\">&amp;</span>[\n            (<span class=\"string\">&quot;flag&quot;</span>, <span class=\"prelude-val\">None</span>, <span class=\"string\">&quot;default&quot;</span>),\n            (<span class=\"string\">&quot;opt&quot;</span>, <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;channal&quot;</span>), <span class=\"string\">&quot;chan&quot;</span>),\n        ]))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;other&quot;</span>), <span class=\"prelude-val\">None</span>);</code></pre></div>\n<p>We can also see that these values are applied in order, and if more than one condition is\ntrue, only the first evaluated “wins”</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .long(<span class=\"string\">&quot;opt&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;other&quot;</span>)\n        .long(<span class=\"string\">&quot;other&quot;</span>)\n        .default_value_ifs(<span class=\"kw-2\">&amp;</span>[\n            (<span class=\"string\">&quot;flag&quot;</span>, <span class=\"prelude-val\">None</span>, <span class=\"string\">&quot;default&quot;</span>),\n            (<span class=\"string\">&quot;opt&quot;</span>, <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;channal&quot;</span>), <span class=\"string\">&quot;chan&quot;</span>),\n        ]))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--opt&quot;</span>, <span class=\"string\">&quot;channal&quot;</span>, <span class=\"string\">&quot;--flag&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;other&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;default&quot;</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.default_value_ifs_os\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3485\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.default_value_ifs_os\" class=\"fn\">default_value_ifs_os</a>(\n    self,\n    ifs: &amp;[(&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>, <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;'b <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>&gt;, &amp;'b <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>)]\n) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Provides multiple conditional default values in the exact same manner as\n<a href=\"clap/args/arg/struct.Arg.html#method.default_value_ifs\" title=\"method clap::args::arg::Arg::default_value_ifs\"><code>Arg::default_value_ifs</code></a> only using <a href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\"><code>OsStr</code></a>s instead.\n<a href=\"clap/args/arg/struct.Arg.html#method.default_value_ifs\" title=\"method clap::args::arg::Arg::default_value_ifs\"><code>Arg::default_value_ifs</code></a>: ./struct.Arg.html#method.default_value_ifs\n<a href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\"><code>OsStr</code></a>: https://doc.rust-lang.org/std/ffi/struct.OsStr.html</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.env\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3597\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.env\" class=\"fn\">env</a>(self, name: &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies that if the value is not passed in as an argument, that it should be retrieved\nfrom the environment, if available. If it is not present in the environment, then default\nrules will apply.</p>\n<p><strong>NOTE:</strong> If the user <em>does not</em> use this argument at runtime, <a href=\"./struct.ArgMatches.html#method.occurrences_of\"><code>ArgMatches::occurrences_of</code></a>\nwill return <code>0</code> even though the <a href=\"./struct.ArgMatches.html#method.value_of\"><code>ArgMatches::value_of</code></a> will return the default specified.</p>\n<p><strong>NOTE:</strong> If the user <em>does not</em> use this argument at runtime <a href=\"./struct.ArgMatches.html#method.is_present\"><code>ArgMatches::is_present</code></a> will\nreturn <code>true</code> if the variable is present in the environment . If you wish to determine whether\nthe argument was used at runtime or not, consider <a href=\"./struct.ArgMatches.html#method.occurrences_of\"><code>ArgMatches::occurrences_of</code></a> which will\nreturn <code>0</code> if the argument was <em>not</em> used at runtime.</p>\n<p><strong>NOTE:</strong> This implicitly sets <a href=\"./struct.Arg.html#method.takes_value\"><code>Arg::takes_value(true)</code></a>.</p>\n<p><strong>NOTE:</strong> If <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a> is set then <a href=\"./struct.Arg.html#method.use_delimiter\"><code>Arg::use_delimiter(true)</code></a> should also be\nset. Otherwise, only a single argument will be returned from the environment variable. The\ndefault delimiter is <code>,</code> and follows all the other delimiter rules.</p>\n<h5 id=\"examples-54\"><a href=\"#examples-54\">Examples</a></h5>\n<p>In this example, we show the variable coming from the environment:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>\nenv::set_var(<span class=\"string\">&quot;MY_FLAG&quot;</span>, <span class=\"string\">&quot;env&quot;</span>);\n\n<span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>)\n        .env(<span class=\"string\">&quot;MY_FLAG&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;flag&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;env&quot;</span>));</code></pre></div>\n<p>In this example, we show the variable coming from an option on the CLI:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>\nenv::set_var(<span class=\"string\">&quot;MY_FLAG&quot;</span>, <span class=\"string\">&quot;env&quot;</span>);\n\n<span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>)\n        .env(<span class=\"string\">&quot;MY_FLAG&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--flag&quot;</span>, <span class=\"string\">&quot;opt&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;flag&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;opt&quot;</span>));</code></pre></div>\n<p>In this example, we show the variable coming from the environment even with the\npresence of a default:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>\nenv::set_var(<span class=\"string\">&quot;MY_FLAG&quot;</span>, <span class=\"string\">&quot;env&quot;</span>);\n\n<span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>)\n        .env(<span class=\"string\">&quot;MY_FLAG&quot;</span>)\n        .default_value(<span class=\"string\">&quot;default&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.value_of(<span class=\"string\">&quot;flag&quot;</span>), <span class=\"prelude-val\">Some</span>(<span class=\"string\">&quot;env&quot;</span>));</code></pre></div>\n<p>In this example, we show the use of multiple values in a single environment variable:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>\nenv::set_var(<span class=\"string\">&quot;MY_FLAG_MULTI&quot;</span>, <span class=\"string\">&quot;env1,env2&quot;</span>);\n\n<span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;flag&quot;</span>)\n        .long(<span class=\"string\">&quot;flag&quot;</span>)\n        .env(<span class=\"string\">&quot;MY_FLAG_MULTI&quot;</span>)\n        .multiple(<span class=\"bool-val\">true</span>)\n        .use_delimiter(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;\n    </span>]);\n\n<span class=\"macro\">assert_eq!</span>(m.values_of(<span class=\"string\">&quot;flag&quot;</span>).unwrap().collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), <span class=\"macro\">vec!</span>[<span class=\"string\">&quot;env1&quot;</span>, <span class=\"string\">&quot;env2&quot;</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.env_os\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3604\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.env_os\" class=\"fn\">env_os</a>(self, name: &amp;'a <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Specifies that if the value is not passed in as an argument, that it should be retrieved\nfrom the environment if available in the exact same manner as <a href=\"clap/args/arg/struct.Arg.html#method.env\" title=\"method clap::args::arg::Arg::env\"><code>Arg::env</code></a> only using\n<a href=\"https://doc.rust-lang.org/nightly/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\"><code>OsStr</code></a>s instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hide_env_values\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3612\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.hide_env_values\" class=\"fn\">hide_env_values</a>(self, hide: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>@TODO @p2 @docs @release: write docs</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.next_line_help\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3665\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.next_line_help\" class=\"fn\">next_line_help</a>(self, nlh: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>When set to <code>true</code> the help string will be displayed on the line after the argument and\nindented once. This can be helpful for arguments with very long or complex help messages.\nThis can also be helpful for arguments with very long flag names, or many/long value names.</p>\n<p><strong>NOTE:</strong> To apply this setting to all arguments consider using\n<a href=\"./enum.AppSettings.html#variant.NextLineHelp\"><code>AppSettings::NextLineHelp</code></a></p>\n<h5 id=\"examples-55\"><a href=\"#examples-55\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;opt&quot;</span>)\n        .long(<span class=\"string\">&quot;long-option-flag&quot;</span>)\n        .short(<span class=\"string\">&quot;o&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .value_names(<span class=\"kw-2\">&amp;</span>[<span class=\"string\">&quot;value1&quot;</span>, <span class=\"string\">&quot;value2&quot;</span>])\n        .help(<span class=\"string\">&quot;Some really long help and complex\\n\\\n               help that makes more sense to be\\n\\\n               on a line after the option&quot;</span>)\n        .next_line_help(<span class=\"bool-val\">true</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>The above example displays the following help message</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>nlh\n\nUSAGE:\n    nlh [FLAGS] [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    -o, --long-option-flag &lt;value1&gt; &lt;value2&gt;\n        Some really long help and complex\n        help that makes more sense to be\n        on a line after the option\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.display_order\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3729\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.display_order\" class=\"fn\">display_order</a>(self, ord: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Allows custom ordering of args within the help message. Args with a lower value will be\ndisplayed first in the help message. This is helpful when one would like to emphasise\nfrequently used args, or prioritize those towards the top of the list. Duplicate values\n<strong>are</strong> allowed. Args with duplicate display orders will be displayed in alphabetical\norder.</p>\n<p><strong>NOTE:</strong> The default is 999 for all arguments.</p>\n<p><strong>NOTE:</strong> This setting is ignored for <a href=\"./struct.Arg.html#method.index\">positional arguments</a> which are always displayed in\n<a href=\"./struct.Arg.html#method.index\">index</a> order.</p>\n<h5 id=\"examples-56\"><a href=\"#examples-56\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;a&quot;</span>) <span class=\"comment\">// Typically args are grouped alphabetically by name.\n                             // Args without a display_order have a value of 999 and are\n                             // displayed alphabetically with all other 999 valued args.\n        </span>.long(<span class=\"string\">&quot;long-option&quot;</span>)\n        .short(<span class=\"string\">&quot;o&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .help(<span class=\"string\">&quot;Some help and text&quot;</span>))\n    .arg(Arg::with_name(<span class=\"string\">&quot;b&quot;</span>)\n        .long(<span class=\"string\">&quot;other-option&quot;</span>)\n        .short(<span class=\"string\">&quot;O&quot;</span>)\n        .takes_value(<span class=\"bool-val\">true</span>)\n        .display_order(<span class=\"number\">1</span>)   <span class=\"comment\">// In order to force this arg to appear *first*\n                            // all we have to do is give it a value lower than 999.\n                            // Any other args with a value of 1 will be displayed\n                            // alphabetically with this one...then 2 values, then 3, etc.\n        </span>.help(<span class=\"string\">&quot;I should be first!&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>The above example displays the following help message</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>cust-ord\n\nUSAGE:\n    cust-ord [FLAGS] [OPTIONS]\n\nFLAGS:\n    -h, --help       Prints help information\n    -V, --version    Prints version information\n\nOPTIONS:\n    -O, --other-option &lt;b&gt;    I should be first!\n    -o, --long-option &lt;a&gt;     Some help and text\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.raw\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3753\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.raw\" class=\"fn\">raw</a>(self, raw: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Indicates that all parameters passed after this should not be parsed\nindividually, but rather passed in their entirety. It is worth noting\nthat setting this requires all values to come after a <code>--</code> to indicate they\nshould all be captured. For example:</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>--foo something -- -v -v -v -b -b -b --baz -q -u -x\n</code></pre></div>\n<p>Will result in everything after <code>--</code> to be considered one raw argument. This behavior\nmay not be exactly what you are expecting and using <a href=\"./enum.AppSettings.html#variant.TrailingVarArg\"><code>AppSettings::TrailingVarArg</code></a>\nmay be more appropriate.</p>\n<p><strong>NOTE:</strong> Implicitly sets <a href=\"./struct.Arg.html#method.multiple\"><code>Arg::multiple(true)</code></a>, <a href=\"./struct.Arg.html#method.allow_hyphen_values\"><code>Arg::allow_hyphen_values(true)</code></a>, and\n<a href=\"./struct.Arg.html#method.last\"><code>Arg::last(true)</code></a> when set to <code>true</code></p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hidden_short_help\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3826\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.hidden_short_help\" class=\"fn\">hidden_short_help</a>(self, hide: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Hides an argument from short help message output.</p>\n<p><strong>NOTE:</strong> This does <strong>not</strong> hide the argument from usage strings on error</p>\n<p><strong>NOTE:</strong> Setting this option will cause next-line-help output style to be used\nwhen long help (<code>--help</code>) is called.</p>\n<h5 id=\"examples-57\"><a href=\"#examples-57\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n    .hidden_short_help(<span class=\"bool-val\">true</span>)</code></pre></div>\n<p>Setting <code>hidden_short_help(true)</code> will hide the argument when displaying short help text</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .hidden_short_help(<span class=\"bool-val\">true</span>)\n        .help(<span class=\"string\">&quot;Some help text describing the --config arg&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-h&quot;\n    </span>]);</code></pre></div>\n<p>The above example displays</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>helptest\n\nUSAGE:\n   helptest [FLAGS]\n\nFLAGS:\n-h, --help       Prints help information\n-V, --version    Prints version information\n</code></pre></div>\n<p>However, when –help is called</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .hidden_short_help(<span class=\"bool-val\">true</span>)\n        .help(<span class=\"string\">&quot;Some help text describing the --config arg&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>Then the following would be displayed</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>helptest\n\nUSAGE:\n   helptest [FLAGS]\n\nFLAGS:\n    --config     Some help text describing the --config arg\n-h, --help       Prints help information\n-V, --version    Prints version information\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.hidden_long_help\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3903\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.hidden_long_help\" class=\"fn\">hidden_long_help</a>(self, hide: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Hides an argument from long help message output.</p>\n<p><strong>NOTE:</strong> This does <strong>not</strong> hide the argument from usage strings on error</p>\n<p><strong>NOTE:</strong> Setting this option will cause next-line-help output style to be used\nwhen long help (<code>--help</code>) is called.</p>\n<h5 id=\"examples-58\"><a href=\"#examples-58\">Examples</a></h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>Arg::with_name(<span class=\"string\">&quot;debug&quot;</span>)\n    .hidden_long_help(<span class=\"bool-val\">true</span>)</code></pre></div>\n<p>Setting <code>hidden_long_help(true)</code> will hide the argument when displaying long help text</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .hidden_long_help(<span class=\"bool-val\">true</span>)\n        .help(<span class=\"string\">&quot;Some help text describing the --config arg&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;--help&quot;\n    </span>]);</code></pre></div>\n<p>The above example displays</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>helptest\n\nUSAGE:\n   helptest [FLAGS]\n\nFLAGS:\n-h, --help       Prints help information\n-V, --version    Prints version information\n</code></pre></div>\n<p>However, when -h is called</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>m = App::new(<span class=\"string\">&quot;prog&quot;</span>)\n    .arg(Arg::with_name(<span class=\"string\">&quot;cfg&quot;</span>)\n        .long(<span class=\"string\">&quot;config&quot;</span>)\n        .hidden_long_help(<span class=\"bool-val\">true</span>)\n        .help(<span class=\"string\">&quot;Some help text describing the --config arg&quot;</span>))\n    .get_matches_from(<span class=\"macro\">vec!</span>[\n        <span class=\"string\">&quot;prog&quot;</span>, <span class=\"string\">&quot;-h&quot;\n    </span>]);</code></pre></div>\n<p>Then the following would be displayed</p>\n<div class=\"example-wrap\"><pre class=\"language-notrust\"><code>helptest\n\nUSAGE:\n   helptest [FLAGS]\n\nFLAGS:\n    --config     Some help text describing the --config arg\n-h, --help       Prints help information\n-V, --version    Prints version information\n</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_set\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3914\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.is_set\" class=\"fn\">is_set</a>(&amp;self, s: <a class=\"enum\" href=\"clap/args/settings/enum.ArgSettings.html\" title=\"enum clap::args::settings::ArgSettings\">ArgSettings</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks if one of the <a href=\"./enum.ArgSettings.html\"><code>ArgSettings</code></a> settings is set for the argument.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.set\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3921\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.set\" class=\"fn\">set</a>(self, s: <a class=\"enum\" href=\"clap/args/settings/enum.ArgSettings.html\" title=\"enum clap::args::settings::ArgSettings\">ArgSettings</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Sets one of the <a href=\"./enum.ArgSettings.html\"><code>ArgSettings</code></a> settings for the argument.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.unset\" class=\"method\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3929\">source</a><h4 class=\"code-header\">pub fn <a href=\"clap/args/arg/struct.Arg.html#tymethod.unset\" class=\"fn\">unset</a>(self, s: <a class=\"enum\" href=\"clap/args/settings/enum.ArgSettings.html\" title=\"enum clap::args::settings::ArgSettings\">ArgSettings</a>) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class=\"docblock\"><p>Unsets one of the <a href=\"./enum.ArgSettings.html\"><code>ArgSettings</code></a> settings for the argument.</p>\n</div></details></div></details>",0,"rg::app::Arg"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq-for-Arg%3C'n,+'e%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3957\">source</a><a href=\"#impl-PartialEq-for-Arg%3C'n,+'e%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'n, 'e&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'n, 'e&gt;&gt; for <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'n, 'e&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3958\">source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'n, 'e&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used\nby <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#239\">source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always\nsufficient, and should not be overridden without very good reason.</div></details></div></details>","PartialEq<Arg<'n, 'e>>","rg::app::Arg"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3C%26Arg%3C'a,+'b%3E%3E-for-Arg%3C'a,+'b%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3945\">source</a><a href=\"#impl-From%3C%26Arg%3C'a,+'b%3E%3E-for-Arg%3C'a,+'b%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, 'b, 'z&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/convert/trait.From.html\" title=\"trait core::convert::From\">From</a>&lt;&amp;'z <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;&gt; for <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#3946\">source</a><a href=\"#method.from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(a: &amp;'z <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details>","From<&'z Arg<'a, 'b>>","rg::app::Arg"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Default-for-Arg%3C'a,+'b%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#48\">source</a><a href=\"#impl-Default-for-Arg%3C'a,+'b%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html\" title=\"trait core::default::Default\">Default</a> for <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;<span class=\"where fmt-newline\">where\n    'a: 'b,</span></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#48\">source</a><a href=\"#method.default\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default\">Read more</a></div></details></div></details>","Default","rg::app::Arg"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Arg%3C'a,+'b%3E\" class=\"impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#48\">source</a><a href=\"#impl-Clone-for-Arg%3C'a,+'b%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;'a, 'b&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> for <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;<span class=\"where fmt-newline\">where\n    'a: 'b,</span></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"src/clap/args/arg.rs.html#48\">source</a><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; <a class=\"struct\" href=\"clap/args/arg/struct.Arg.html\" title=\"struct clap::args::arg::Arg\">Arg</a>&lt;'a, 'b&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details>","Clone","rg::app::Arg"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()